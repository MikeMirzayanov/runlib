// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/contester/runlib/contester_proto/Local.proto

package contester_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type BinaryTypeResponse_Win32BinaryType int32

const (
	BinaryTypeResponse_SCS_32BIT_BINARY BinaryTypeResponse_Win32BinaryType = 0
	BinaryTypeResponse_SCS_DOS_BINARY   BinaryTypeResponse_Win32BinaryType = 1
	BinaryTypeResponse_SCS_WOW_BINARY   BinaryTypeResponse_Win32BinaryType = 2
	BinaryTypeResponse_SCS_PIF_BINARY   BinaryTypeResponse_Win32BinaryType = 3
	BinaryTypeResponse_SCS_POSIX_BINARY BinaryTypeResponse_Win32BinaryType = 4
	BinaryTypeResponse_SCS_OS216_BINARY BinaryTypeResponse_Win32BinaryType = 5
	BinaryTypeResponse_SCS_64BIT_BINARY BinaryTypeResponse_Win32BinaryType = 6
)

var BinaryTypeResponse_Win32BinaryType_name = map[int32]string{
	0: "SCS_32BIT_BINARY",
	1: "SCS_DOS_BINARY",
	2: "SCS_WOW_BINARY",
	3: "SCS_PIF_BINARY",
	4: "SCS_POSIX_BINARY",
	5: "SCS_OS216_BINARY",
	6: "SCS_64BIT_BINARY",
}
var BinaryTypeResponse_Win32BinaryType_value = map[string]int32{
	"SCS_32BIT_BINARY": 0,
	"SCS_DOS_BINARY":   1,
	"SCS_WOW_BINARY":   2,
	"SCS_PIF_BINARY":   3,
	"SCS_POSIX_BINARY": 4,
	"SCS_OS216_BINARY": 5,
	"SCS_64BIT_BINARY": 6,
}

func (x BinaryTypeResponse_Win32BinaryType) String() string {
	return proto.EnumName(BinaryTypeResponse_Win32BinaryType_name, int32(x))
}
func (BinaryTypeResponse_Win32BinaryType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorLocal, []int{7, 0}
}

type LocalEnvironment struct {
	Empty    bool                         `protobuf:"varint,1,opt,name=empty,proto3" json:"empty,omitempty"`
	Variable []*LocalEnvironment_Variable `protobuf:"bytes,2,rep,name=variable" json:"variable,omitempty"`
}

func (m *LocalEnvironment) Reset()                    { *m = LocalEnvironment{} }
func (*LocalEnvironment) ProtoMessage()               {}
func (*LocalEnvironment) Descriptor() ([]byte, []int) { return fileDescriptorLocal, []int{0} }

func (m *LocalEnvironment) GetEmpty() bool {
	if m != nil {
		return m.Empty
	}
	return false
}

func (m *LocalEnvironment) GetVariable() []*LocalEnvironment_Variable {
	if m != nil {
		return m.Variable
	}
	return nil
}

type LocalEnvironment_Variable struct {
	Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value  string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Expand bool   `protobuf:"varint,3,opt,name=expand,proto3" json:"expand,omitempty"`
}

func (m *LocalEnvironment_Variable) Reset()      { *m = LocalEnvironment_Variable{} }
func (*LocalEnvironment_Variable) ProtoMessage() {}
func (*LocalEnvironment_Variable) Descriptor() ([]byte, []int) {
	return fileDescriptorLocal, []int{0, 0}
}

func (m *LocalEnvironment_Variable) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LocalEnvironment_Variable) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *LocalEnvironment_Variable) GetExpand() bool {
	if m != nil {
		return m.Expand
	}
	return false
}

type LocalExecutionParameters struct {
	ApplicationName       string              `protobuf:"bytes,1,opt,name=application_name,json=applicationName,proto3" json:"application_name,omitempty"`
	CommandLine           string              `protobuf:"bytes,2,opt,name=command_line,json=commandLine,proto3" json:"command_line,omitempty"`
	CurrentDirectory      string              `protobuf:"bytes,3,opt,name=current_directory,json=currentDirectory,proto3" json:"current_directory,omitempty"`
	TimeLimitMicros       uint64              `protobuf:"varint,4,opt,name=time_limit_micros,json=timeLimitMicros,proto3" json:"time_limit_micros,omitempty"`
	MemoryLimit           uint64              `protobuf:"varint,5,opt,name=memory_limit,json=memoryLimit,proto3" json:"memory_limit,omitempty"`
	CheckIdleness         bool                `protobuf:"varint,6,opt,name=check_idleness,json=checkIdleness,proto3" json:"check_idleness,omitempty"`
	Environment           *LocalEnvironment   `protobuf:"bytes,7,opt,name=environment" json:"environment,omitempty"`
	RestrictUi            bool                `protobuf:"varint,8,opt,name=restrict_ui,json=restrictUi,proto3" json:"restrict_ui,omitempty"`
	NoJob                 bool                `protobuf:"varint,9,opt,name=no_job,json=noJob,proto3" json:"no_job,omitempty"`
	ProcessLimit          uint32              `protobuf:"varint,10,opt,name=process_limit,json=processLimit,proto3" json:"process_limit,omitempty"`
	KernelTimeLimitMicros uint64              `protobuf:"varint,19,opt,name=kernel_time_limit_micros,json=kernelTimeLimitMicros,proto3" json:"kernel_time_limit_micros,omitempty"`
	WallTimeLimitMicros   uint64              `protobuf:"varint,20,opt,name=wall_time_limit_micros,json=wallTimeLimitMicros,proto3" json:"wall_time_limit_micros,omitempty"`
	StdIn                 *RedirectParameters `protobuf:"bytes,12,opt,name=std_in,json=stdIn" json:"std_in,omitempty"`
	StdOut                *RedirectParameters `protobuf:"bytes,13,opt,name=std_out,json=stdOut" json:"std_out,omitempty"`
	StdErr                *RedirectParameters `protobuf:"bytes,14,opt,name=std_err,json=stdErr" json:"std_err,omitempty"`
	CommandLineParameters []string            `protobuf:"bytes,16,rep,name=command_line_parameters,json=commandLineParameters" json:"command_line_parameters,omitempty"`
	SandboxId             string              `protobuf:"bytes,17,opt,name=sandbox_id,json=sandboxId,proto3" json:"sandbox_id,omitempty"`
	JoinStdoutStderr      bool                `protobuf:"varint,18,opt,name=join_stdout_stderr,json=joinStdoutStderr,proto3" json:"join_stdout_stderr,omitempty"`
}

func (m *LocalExecutionParameters) Reset()                    { *m = LocalExecutionParameters{} }
func (*LocalExecutionParameters) ProtoMessage()               {}
func (*LocalExecutionParameters) Descriptor() ([]byte, []int) { return fileDescriptorLocal, []int{1} }

func (m *LocalExecutionParameters) GetApplicationName() string {
	if m != nil {
		return m.ApplicationName
	}
	return ""
}

func (m *LocalExecutionParameters) GetCommandLine() string {
	if m != nil {
		return m.CommandLine
	}
	return ""
}

func (m *LocalExecutionParameters) GetCurrentDirectory() string {
	if m != nil {
		return m.CurrentDirectory
	}
	return ""
}

func (m *LocalExecutionParameters) GetTimeLimitMicros() uint64 {
	if m != nil {
		return m.TimeLimitMicros
	}
	return 0
}

func (m *LocalExecutionParameters) GetMemoryLimit() uint64 {
	if m != nil {
		return m.MemoryLimit
	}
	return 0
}

func (m *LocalExecutionParameters) GetCheckIdleness() bool {
	if m != nil {
		return m.CheckIdleness
	}
	return false
}

func (m *LocalExecutionParameters) GetEnvironment() *LocalEnvironment {
	if m != nil {
		return m.Environment
	}
	return nil
}

func (m *LocalExecutionParameters) GetRestrictUi() bool {
	if m != nil {
		return m.RestrictUi
	}
	return false
}

func (m *LocalExecutionParameters) GetNoJob() bool {
	if m != nil {
		return m.NoJob
	}
	return false
}

func (m *LocalExecutionParameters) GetProcessLimit() uint32 {
	if m != nil {
		return m.ProcessLimit
	}
	return 0
}

func (m *LocalExecutionParameters) GetKernelTimeLimitMicros() uint64 {
	if m != nil {
		return m.KernelTimeLimitMicros
	}
	return 0
}

func (m *LocalExecutionParameters) GetWallTimeLimitMicros() uint64 {
	if m != nil {
		return m.WallTimeLimitMicros
	}
	return 0
}

func (m *LocalExecutionParameters) GetStdIn() *RedirectParameters {
	if m != nil {
		return m.StdIn
	}
	return nil
}

func (m *LocalExecutionParameters) GetStdOut() *RedirectParameters {
	if m != nil {
		return m.StdOut
	}
	return nil
}

func (m *LocalExecutionParameters) GetStdErr() *RedirectParameters {
	if m != nil {
		return m.StdErr
	}
	return nil
}

func (m *LocalExecutionParameters) GetCommandLineParameters() []string {
	if m != nil {
		return m.CommandLineParameters
	}
	return nil
}

func (m *LocalExecutionParameters) GetSandboxId() string {
	if m != nil {
		return m.SandboxId
	}
	return ""
}

func (m *LocalExecutionParameters) GetJoinStdoutStderr() bool {
	if m != nil {
		return m.JoinStdoutStderr
	}
	return false
}

type LocalExecuteConnected struct {
	First  *LocalExecutionParameters `protobuf:"bytes,1,opt,name=first" json:"first,omitempty"`
	Second *LocalExecutionParameters `protobuf:"bytes,2,opt,name=second" json:"second,omitempty"`
}

func (m *LocalExecuteConnected) Reset()                    { *m = LocalExecuteConnected{} }
func (*LocalExecuteConnected) ProtoMessage()               {}
func (*LocalExecuteConnected) Descriptor() ([]byte, []int) { return fileDescriptorLocal, []int{2} }

func (m *LocalExecuteConnected) GetFirst() *LocalExecutionParameters {
	if m != nil {
		return m.First
	}
	return nil
}

func (m *LocalExecuteConnected) GetSecond() *LocalExecutionParameters {
	if m != nil {
		return m.Second
	}
	return nil
}

type LocalExecutionResult struct {
	Flags          *ExecutionResultFlags `protobuf:"bytes,1,opt,name=flags" json:"flags,omitempty"`
	Time           *ExecutionResultTime  `protobuf:"bytes,2,opt,name=time" json:"time,omitempty"`
	Memory         uint64                `protobuf:"varint,3,opt,name=memory,proto3" json:"memory,omitempty"`
	ReturnCode     uint32                `protobuf:"varint,4,opt,name=return_code,json=returnCode,proto3" json:"return_code,omitempty"`
	StdOut         *Blob                 `protobuf:"bytes,5,opt,name=std_out,json=stdOut" json:"std_out,omitempty"`
	StdErr         *Blob                 `protobuf:"bytes,6,opt,name=std_err,json=stdErr" json:"std_err,omitempty"`
	TotalProcesses uint64                `protobuf:"varint,7,opt,name=total_processes,json=totalProcesses,proto3" json:"total_processes,omitempty"`
	KillSignal     int32                 `protobuf:"varint,8,opt,name=kill_signal,json=killSignal,proto3" json:"kill_signal,omitempty"`
	StopSignal     int32                 `protobuf:"varint,9,opt,name=stop_signal,json=stopSignal,proto3" json:"stop_signal,omitempty"`
	Error          string                `protobuf:"bytes,10,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *LocalExecutionResult) Reset()                    { *m = LocalExecutionResult{} }
func (*LocalExecutionResult) ProtoMessage()               {}
func (*LocalExecutionResult) Descriptor() ([]byte, []int) { return fileDescriptorLocal, []int{3} }

func (m *LocalExecutionResult) GetFlags() *ExecutionResultFlags {
	if m != nil {
		return m.Flags
	}
	return nil
}

func (m *LocalExecutionResult) GetTime() *ExecutionResultTime {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *LocalExecutionResult) GetMemory() uint64 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *LocalExecutionResult) GetReturnCode() uint32 {
	if m != nil {
		return m.ReturnCode
	}
	return 0
}

func (m *LocalExecutionResult) GetStdOut() *Blob {
	if m != nil {
		return m.StdOut
	}
	return nil
}

func (m *LocalExecutionResult) GetStdErr() *Blob {
	if m != nil {
		return m.StdErr
	}
	return nil
}

func (m *LocalExecutionResult) GetTotalProcesses() uint64 {
	if m != nil {
		return m.TotalProcesses
	}
	return 0
}

func (m *LocalExecutionResult) GetKillSignal() int32 {
	if m != nil {
		return m.KillSignal
	}
	return 0
}

func (m *LocalExecutionResult) GetStopSignal() int32 {
	if m != nil {
		return m.StopSignal
	}
	return 0
}

func (m *LocalExecutionResult) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type LocalExecuteConnectedResult struct {
	First  *LocalExecutionResult `protobuf:"bytes,1,opt,name=first" json:"first,omitempty"`
	Second *LocalExecutionResult `protobuf:"bytes,2,opt,name=second" json:"second,omitempty"`
}

func (m *LocalExecuteConnectedResult) Reset()                    { *m = LocalExecuteConnectedResult{} }
func (*LocalExecuteConnectedResult) ProtoMessage()               {}
func (*LocalExecuteConnectedResult) Descriptor() ([]byte, []int) { return fileDescriptorLocal, []int{4} }

func (m *LocalExecuteConnectedResult) GetFirst() *LocalExecutionResult {
	if m != nil {
		return m.First
	}
	return nil
}

func (m *LocalExecuteConnectedResult) GetSecond() *LocalExecutionResult {
	if m != nil {
		return m.Second
	}
	return nil
}

type LocalExecution struct {
	Parameters *LocalExecutionParameters `protobuf:"bytes,1,opt,name=parameters" json:"parameters,omitempty"`
	Result     *LocalExecutionResult     `protobuf:"bytes,2,opt,name=result" json:"result,omitempty"`
}

func (m *LocalExecution) Reset()                    { *m = LocalExecution{} }
func (*LocalExecution) ProtoMessage()               {}
func (*LocalExecution) Descriptor() ([]byte, []int) { return fileDescriptorLocal, []int{5} }

func (m *LocalExecution) GetParameters() *LocalExecutionParameters {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *LocalExecution) GetResult() *LocalExecutionResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type BinaryTypeRequest struct {
	Pathname string `protobuf:"bytes,1,opt,name=pathname,proto3" json:"pathname,omitempty"`
}

func (m *BinaryTypeRequest) Reset()                    { *m = BinaryTypeRequest{} }
func (*BinaryTypeRequest) ProtoMessage()               {}
func (*BinaryTypeRequest) Descriptor() ([]byte, []int) { return fileDescriptorLocal, []int{6} }

func (m *BinaryTypeRequest) GetPathname() string {
	if m != nil {
		return m.Pathname
	}
	return ""
}

type BinaryTypeResponse struct {
	Failure bool                               `protobuf:"varint,1,opt,name=failure,proto3" json:"failure,omitempty"`
	Result  BinaryTypeResponse_Win32BinaryType `protobuf:"varint,2,opt,name=result,proto3,enum=contester.proto.BinaryTypeResponse_Win32BinaryType" json:"result,omitempty"`
}

func (m *BinaryTypeResponse) Reset()                    { *m = BinaryTypeResponse{} }
func (*BinaryTypeResponse) ProtoMessage()               {}
func (*BinaryTypeResponse) Descriptor() ([]byte, []int) { return fileDescriptorLocal, []int{7} }

func (m *BinaryTypeResponse) GetFailure() bool {
	if m != nil {
		return m.Failure
	}
	return false
}

func (m *BinaryTypeResponse) GetResult() BinaryTypeResponse_Win32BinaryType {
	if m != nil {
		return m.Result
	}
	return BinaryTypeResponse_SCS_32BIT_BINARY
}

type ClearSandboxRequest struct {
	Sandbox string `protobuf:"bytes,1,opt,name=sandbox,proto3" json:"sandbox,omitempty"`
}

func (m *ClearSandboxRequest) Reset()                    { *m = ClearSandboxRequest{} }
func (*ClearSandboxRequest) ProtoMessage()               {}
func (*ClearSandboxRequest) Descriptor() ([]byte, []int) { return fileDescriptorLocal, []int{8} }

func (m *ClearSandboxRequest) GetSandbox() string {
	if m != nil {
		return m.Sandbox
	}
	return ""
}

type IdentifyRequest struct {
	ContesterId string `protobuf:"bytes,1,opt,name=contester_id,json=contesterId,proto3" json:"contester_id,omitempty"`
}

func (m *IdentifyRequest) Reset()                    { *m = IdentifyRequest{} }
func (*IdentifyRequest) ProtoMessage()               {}
func (*IdentifyRequest) Descriptor() ([]byte, []int) { return fileDescriptorLocal, []int{9} }

func (m *IdentifyRequest) GetContesterId() string {
	if m != nil {
		return m.ContesterId
	}
	return ""
}

type SandboxLocations struct {
	Compile string `protobuf:"bytes,1,opt,name=compile,proto3" json:"compile,omitempty"`
	Run     string `protobuf:"bytes,2,opt,name=run,proto3" json:"run,omitempty"`
}

func (m *SandboxLocations) Reset()                    { *m = SandboxLocations{} }
func (*SandboxLocations) ProtoMessage()               {}
func (*SandboxLocations) Descriptor() ([]byte, []int) { return fileDescriptorLocal, []int{10} }

func (m *SandboxLocations) GetCompile() string {
	if m != nil {
		return m.Compile
	}
	return ""
}

func (m *SandboxLocations) GetRun() string {
	if m != nil {
		return m.Run
	}
	return ""
}

type IdentifyResponse struct {
	InvokerId     string              `protobuf:"bytes,1,opt,name=invoker_id,json=invokerId,proto3" json:"invoker_id,omitempty"`
	Sandboxes     []*SandboxLocations `protobuf:"bytes,2,rep,name=sandboxes" json:"sandboxes,omitempty"`
	Environment   *LocalEnvironment   `protobuf:"bytes,3,opt,name=environment" json:"environment,omitempty"`
	Platform      string              `protobuf:"bytes,4,opt,name=platform,proto3" json:"platform,omitempty"`
	PathSeparator string              `protobuf:"bytes,5,opt,name=path_separator,json=pathSeparator,proto3" json:"path_separator,omitempty"`
	Disks         []string            `protobuf:"bytes,6,rep,name=disks" json:"disks,omitempty"`
	ProgramFiles  []string            `protobuf:"bytes,7,rep,name=programFiles" json:"programFiles,omitempty"`
}

func (m *IdentifyResponse) Reset()                    { *m = IdentifyResponse{} }
func (*IdentifyResponse) ProtoMessage()               {}
func (*IdentifyResponse) Descriptor() ([]byte, []int) { return fileDescriptorLocal, []int{11} }

func (m *IdentifyResponse) GetInvokerId() string {
	if m != nil {
		return m.InvokerId
	}
	return ""
}

func (m *IdentifyResponse) GetSandboxes() []*SandboxLocations {
	if m != nil {
		return m.Sandboxes
	}
	return nil
}

func (m *IdentifyResponse) GetEnvironment() *LocalEnvironment {
	if m != nil {
		return m.Environment
	}
	return nil
}

func (m *IdentifyResponse) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *IdentifyResponse) GetPathSeparator() string {
	if m != nil {
		return m.PathSeparator
	}
	return ""
}

func (m *IdentifyResponse) GetDisks() []string {
	if m != nil {
		return m.Disks
	}
	return nil
}

func (m *IdentifyResponse) GetProgramFiles() []string {
	if m != nil {
		return m.ProgramFiles
	}
	return nil
}

type FileStat struct {
	Name        string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	IsDirectory bool   `protobuf:"varint,2,opt,name=is_directory,json=isDirectory,proto3" json:"is_directory,omitempty"`
	Size_       uint64 `protobuf:"varint,3,opt,name=size,proto3" json:"size,omitempty"`
	Checksum    string `protobuf:"bytes,4,opt,name=checksum,proto3" json:"checksum,omitempty"`
}

func (m *FileStat) Reset()                    { *m = FileStat{} }
func (*FileStat) ProtoMessage()               {}
func (*FileStat) Descriptor() ([]byte, []int) { return fileDescriptorLocal, []int{12} }

func (m *FileStat) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FileStat) GetIsDirectory() bool {
	if m != nil {
		return m.IsDirectory
	}
	return false
}

func (m *FileStat) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *FileStat) GetChecksum() string {
	if m != nil {
		return m.Checksum
	}
	return ""
}

type StatRequest struct {
	Name              []string `protobuf:"bytes,1,rep,name=name" json:"name,omitempty"`
	SandboxId         string   `protobuf:"bytes,2,opt,name=sandbox_id,json=sandboxId,proto3" json:"sandbox_id,omitempty"`
	Expand            bool     `protobuf:"varint,3,opt,name=expand,proto3" json:"expand,omitempty"`
	CalculateChecksum bool     `protobuf:"varint,4,opt,name=calculate_checksum,json=calculateChecksum,proto3" json:"calculate_checksum,omitempty"`
}

func (m *StatRequest) Reset()                    { *m = StatRequest{} }
func (*StatRequest) ProtoMessage()               {}
func (*StatRequest) Descriptor() ([]byte, []int) { return fileDescriptorLocal, []int{13} }

func (m *StatRequest) GetName() []string {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *StatRequest) GetSandboxId() string {
	if m != nil {
		return m.SandboxId
	}
	return ""
}

func (m *StatRequest) GetExpand() bool {
	if m != nil {
		return m.Expand
	}
	return false
}

func (m *StatRequest) GetCalculateChecksum() bool {
	if m != nil {
		return m.CalculateChecksum
	}
	return false
}

type FileStats struct {
	Entries []*FileStat `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
}

func (m *FileStats) Reset()                    { *m = FileStats{} }
func (*FileStats) ProtoMessage()               {}
func (*FileStats) Descriptor() ([]byte, []int) { return fileDescriptorLocal, []int{14} }

func (m *FileStats) GetEntries() []*FileStat {
	if m != nil {
		return m.Entries
	}
	return nil
}

type GetRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GetRequest) Reset()                    { *m = GetRequest{} }
func (*GetRequest) ProtoMessage()               {}
func (*GetRequest) Descriptor() ([]byte, []int) { return fileDescriptorLocal, []int{15} }

func (m *GetRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type EmptyMessage struct {
}

func (m *EmptyMessage) Reset()                    { *m = EmptyMessage{} }
func (*EmptyMessage) ProtoMessage()               {}
func (*EmptyMessage) Descriptor() ([]byte, []int) { return fileDescriptorLocal, []int{16} }

type CopyOperation struct {
	LocalFileName      string `protobuf:"bytes,1,opt,name=local_file_name,json=localFileName,proto3" json:"local_file_name,omitempty"`
	RemoteLocation     string `protobuf:"bytes,2,opt,name=remote_location,json=remoteLocation,proto3" json:"remote_location,omitempty"`
	Upload             bool   `protobuf:"varint,3,opt,name=upload,proto3" json:"upload,omitempty"`
	Checksum           string `protobuf:"bytes,4,opt,name=checksum,proto3" json:"checksum,omitempty"`
	ModuleType         string `protobuf:"bytes,5,opt,name=module_type,json=moduleType,proto3" json:"module_type,omitempty"`
	AuthorizationToken string `protobuf:"bytes,6,opt,name=authorization_token,json=authorizationToken,proto3" json:"authorization_token,omitempty"`
}

func (m *CopyOperation) Reset()                    { *m = CopyOperation{} }
func (*CopyOperation) ProtoMessage()               {}
func (*CopyOperation) Descriptor() ([]byte, []int) { return fileDescriptorLocal, []int{17} }

func (m *CopyOperation) GetLocalFileName() string {
	if m != nil {
		return m.LocalFileName
	}
	return ""
}

func (m *CopyOperation) GetRemoteLocation() string {
	if m != nil {
		return m.RemoteLocation
	}
	return ""
}

func (m *CopyOperation) GetUpload() bool {
	if m != nil {
		return m.Upload
	}
	return false
}

func (m *CopyOperation) GetChecksum() string {
	if m != nil {
		return m.Checksum
	}
	return ""
}

func (m *CopyOperation) GetModuleType() string {
	if m != nil {
		return m.ModuleType
	}
	return ""
}

func (m *CopyOperation) GetAuthorizationToken() string {
	if m != nil {
		return m.AuthorizationToken
	}
	return ""
}

type CopyOperations struct {
	Entries   []*CopyOperation `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
	SandboxId string           `protobuf:"bytes,2,opt,name=sandbox_id,json=sandboxId,proto3" json:"sandbox_id,omitempty"`
}

func (m *CopyOperations) Reset()                    { *m = CopyOperations{} }
func (*CopyOperations) ProtoMessage()               {}
func (*CopyOperations) Descriptor() ([]byte, []int) { return fileDescriptorLocal, []int{18} }

func (m *CopyOperations) GetEntries() []*CopyOperation {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *CopyOperations) GetSandboxId() string {
	if m != nil {
		return m.SandboxId
	}
	return ""
}

type NamePair struct {
	Source      string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Destination string `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
}

func (m *NamePair) Reset()                    { *m = NamePair{} }
func (*NamePair) ProtoMessage()               {}
func (*NamePair) Descriptor() ([]byte, []int) { return fileDescriptorLocal, []int{19} }

func (m *NamePair) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *NamePair) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

type RepeatedNamePairEntries struct {
	Entries   []*NamePair `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
	SandboxId string      `protobuf:"bytes,2,opt,name=sandbox_id,json=sandboxId,proto3" json:"sandbox_id,omitempty"`
}

func (m *RepeatedNamePairEntries) Reset()                    { *m = RepeatedNamePairEntries{} }
func (*RepeatedNamePairEntries) ProtoMessage()               {}
func (*RepeatedNamePairEntries) Descriptor() ([]byte, []int) { return fileDescriptorLocal, []int{20} }

func (m *RepeatedNamePairEntries) GetEntries() []*NamePair {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *RepeatedNamePairEntries) GetSandboxId() string {
	if m != nil {
		return m.SandboxId
	}
	return ""
}

type RepeatedStringEntries struct {
	Entries []string `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
}

func (m *RepeatedStringEntries) Reset()                    { *m = RepeatedStringEntries{} }
func (*RepeatedStringEntries) ProtoMessage()               {}
func (*RepeatedStringEntries) Descriptor() ([]byte, []int) { return fileDescriptorLocal, []int{21} }

func (m *RepeatedStringEntries) GetEntries() []string {
	if m != nil {
		return m.Entries
	}
	return nil
}

func init() {
	proto.RegisterType((*LocalEnvironment)(nil), "contester.proto.LocalEnvironment")
	proto.RegisterType((*LocalEnvironment_Variable)(nil), "contester.proto.LocalEnvironment.Variable")
	proto.RegisterType((*LocalExecutionParameters)(nil), "contester.proto.LocalExecutionParameters")
	proto.RegisterType((*LocalExecuteConnected)(nil), "contester.proto.LocalExecuteConnected")
	proto.RegisterType((*LocalExecutionResult)(nil), "contester.proto.LocalExecutionResult")
	proto.RegisterType((*LocalExecuteConnectedResult)(nil), "contester.proto.LocalExecuteConnectedResult")
	proto.RegisterType((*LocalExecution)(nil), "contester.proto.LocalExecution")
	proto.RegisterType((*BinaryTypeRequest)(nil), "contester.proto.BinaryTypeRequest")
	proto.RegisterType((*BinaryTypeResponse)(nil), "contester.proto.BinaryTypeResponse")
	proto.RegisterType((*ClearSandboxRequest)(nil), "contester.proto.ClearSandboxRequest")
	proto.RegisterType((*IdentifyRequest)(nil), "contester.proto.IdentifyRequest")
	proto.RegisterType((*SandboxLocations)(nil), "contester.proto.SandboxLocations")
	proto.RegisterType((*IdentifyResponse)(nil), "contester.proto.IdentifyResponse")
	proto.RegisterType((*FileStat)(nil), "contester.proto.FileStat")
	proto.RegisterType((*StatRequest)(nil), "contester.proto.StatRequest")
	proto.RegisterType((*FileStats)(nil), "contester.proto.FileStats")
	proto.RegisterType((*GetRequest)(nil), "contester.proto.GetRequest")
	proto.RegisterType((*EmptyMessage)(nil), "contester.proto.EmptyMessage")
	proto.RegisterType((*CopyOperation)(nil), "contester.proto.CopyOperation")
	proto.RegisterType((*CopyOperations)(nil), "contester.proto.CopyOperations")
	proto.RegisterType((*NamePair)(nil), "contester.proto.NamePair")
	proto.RegisterType((*RepeatedNamePairEntries)(nil), "contester.proto.RepeatedNamePairEntries")
	proto.RegisterType((*RepeatedStringEntries)(nil), "contester.proto.RepeatedStringEntries")
	proto.RegisterEnum("contester.proto.BinaryTypeResponse_Win32BinaryType", BinaryTypeResponse_Win32BinaryType_name, BinaryTypeResponse_Win32BinaryType_value)
}
func (this *LocalEnvironment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalEnvironment)
	if !ok {
		that2, ok := that.(LocalEnvironment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Empty != that1.Empty {
		return false
	}
	if len(this.Variable) != len(that1.Variable) {
		return false
	}
	for i := range this.Variable {
		if !this.Variable[i].Equal(that1.Variable[i]) {
			return false
		}
	}
	return true
}
func (this *LocalEnvironment_Variable) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalEnvironment_Variable)
	if !ok {
		that2, ok := that.(LocalEnvironment_Variable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Expand != that1.Expand {
		return false
	}
	return true
}
func (this *LocalExecutionParameters) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalExecutionParameters)
	if !ok {
		that2, ok := that.(LocalExecutionParameters)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ApplicationName != that1.ApplicationName {
		return false
	}
	if this.CommandLine != that1.CommandLine {
		return false
	}
	if this.CurrentDirectory != that1.CurrentDirectory {
		return false
	}
	if this.TimeLimitMicros != that1.TimeLimitMicros {
		return false
	}
	if this.MemoryLimit != that1.MemoryLimit {
		return false
	}
	if this.CheckIdleness != that1.CheckIdleness {
		return false
	}
	if !this.Environment.Equal(that1.Environment) {
		return false
	}
	if this.RestrictUi != that1.RestrictUi {
		return false
	}
	if this.NoJob != that1.NoJob {
		return false
	}
	if this.ProcessLimit != that1.ProcessLimit {
		return false
	}
	if this.KernelTimeLimitMicros != that1.KernelTimeLimitMicros {
		return false
	}
	if this.WallTimeLimitMicros != that1.WallTimeLimitMicros {
		return false
	}
	if !this.StdIn.Equal(that1.StdIn) {
		return false
	}
	if !this.StdOut.Equal(that1.StdOut) {
		return false
	}
	if !this.StdErr.Equal(that1.StdErr) {
		return false
	}
	if len(this.CommandLineParameters) != len(that1.CommandLineParameters) {
		return false
	}
	for i := range this.CommandLineParameters {
		if this.CommandLineParameters[i] != that1.CommandLineParameters[i] {
			return false
		}
	}
	if this.SandboxId != that1.SandboxId {
		return false
	}
	if this.JoinStdoutStderr != that1.JoinStdoutStderr {
		return false
	}
	return true
}
func (this *LocalExecuteConnected) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalExecuteConnected)
	if !ok {
		that2, ok := that.(LocalExecuteConnected)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.First.Equal(that1.First) {
		return false
	}
	if !this.Second.Equal(that1.Second) {
		return false
	}
	return true
}
func (this *LocalExecutionResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalExecutionResult)
	if !ok {
		that2, ok := that.(LocalExecutionResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Flags.Equal(that1.Flags) {
		return false
	}
	if !this.Time.Equal(that1.Time) {
		return false
	}
	if this.Memory != that1.Memory {
		return false
	}
	if this.ReturnCode != that1.ReturnCode {
		return false
	}
	if !this.StdOut.Equal(that1.StdOut) {
		return false
	}
	if !this.StdErr.Equal(that1.StdErr) {
		return false
	}
	if this.TotalProcesses != that1.TotalProcesses {
		return false
	}
	if this.KillSignal != that1.KillSignal {
		return false
	}
	if this.StopSignal != that1.StopSignal {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	return true
}
func (this *LocalExecuteConnectedResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalExecuteConnectedResult)
	if !ok {
		that2, ok := that.(LocalExecuteConnectedResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.First.Equal(that1.First) {
		return false
	}
	if !this.Second.Equal(that1.Second) {
		return false
	}
	return true
}
func (this *LocalExecution) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalExecution)
	if !ok {
		that2, ok := that.(LocalExecution)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Parameters.Equal(that1.Parameters) {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	return true
}
func (this *BinaryTypeRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BinaryTypeRequest)
	if !ok {
		that2, ok := that.(BinaryTypeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Pathname != that1.Pathname {
		return false
	}
	return true
}
func (this *BinaryTypeResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BinaryTypeResponse)
	if !ok {
		that2, ok := that.(BinaryTypeResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Failure != that1.Failure {
		return false
	}
	if this.Result != that1.Result {
		return false
	}
	return true
}
func (this *ClearSandboxRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClearSandboxRequest)
	if !ok {
		that2, ok := that.(ClearSandboxRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Sandbox != that1.Sandbox {
		return false
	}
	return true
}
func (this *IdentifyRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IdentifyRequest)
	if !ok {
		that2, ok := that.(IdentifyRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ContesterId != that1.ContesterId {
		return false
	}
	return true
}
func (this *SandboxLocations) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SandboxLocations)
	if !ok {
		that2, ok := that.(SandboxLocations)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Compile != that1.Compile {
		return false
	}
	if this.Run != that1.Run {
		return false
	}
	return true
}
func (this *IdentifyResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IdentifyResponse)
	if !ok {
		that2, ok := that.(IdentifyResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.InvokerId != that1.InvokerId {
		return false
	}
	if len(this.Sandboxes) != len(that1.Sandboxes) {
		return false
	}
	for i := range this.Sandboxes {
		if !this.Sandboxes[i].Equal(that1.Sandboxes[i]) {
			return false
		}
	}
	if !this.Environment.Equal(that1.Environment) {
		return false
	}
	if this.Platform != that1.Platform {
		return false
	}
	if this.PathSeparator != that1.PathSeparator {
		return false
	}
	if len(this.Disks) != len(that1.Disks) {
		return false
	}
	for i := range this.Disks {
		if this.Disks[i] != that1.Disks[i] {
			return false
		}
	}
	if len(this.ProgramFiles) != len(that1.ProgramFiles) {
		return false
	}
	for i := range this.ProgramFiles {
		if this.ProgramFiles[i] != that1.ProgramFiles[i] {
			return false
		}
	}
	return true
}
func (this *FileStat) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FileStat)
	if !ok {
		that2, ok := that.(FileStat)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.IsDirectory != that1.IsDirectory {
		return false
	}
	if this.Size_ != that1.Size_ {
		return false
	}
	if this.Checksum != that1.Checksum {
		return false
	}
	return true
}
func (this *StatRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StatRequest)
	if !ok {
		that2, ok := that.(StatRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Name) != len(that1.Name) {
		return false
	}
	for i := range this.Name {
		if this.Name[i] != that1.Name[i] {
			return false
		}
	}
	if this.SandboxId != that1.SandboxId {
		return false
	}
	if this.Expand != that1.Expand {
		return false
	}
	if this.CalculateChecksum != that1.CalculateChecksum {
		return false
	}
	return true
}
func (this *FileStats) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FileStats)
	if !ok {
		that2, ok := that.(FileStats)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Entries) != len(that1.Entries) {
		return false
	}
	for i := range this.Entries {
		if !this.Entries[i].Equal(that1.Entries[i]) {
			return false
		}
	}
	return true
}
func (this *GetRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetRequest)
	if !ok {
		that2, ok := that.(GetRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *EmptyMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EmptyMessage)
	if !ok {
		that2, ok := that.(EmptyMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *CopyOperation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CopyOperation)
	if !ok {
		that2, ok := that.(CopyOperation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LocalFileName != that1.LocalFileName {
		return false
	}
	if this.RemoteLocation != that1.RemoteLocation {
		return false
	}
	if this.Upload != that1.Upload {
		return false
	}
	if this.Checksum != that1.Checksum {
		return false
	}
	if this.ModuleType != that1.ModuleType {
		return false
	}
	if this.AuthorizationToken != that1.AuthorizationToken {
		return false
	}
	return true
}
func (this *CopyOperations) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CopyOperations)
	if !ok {
		that2, ok := that.(CopyOperations)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Entries) != len(that1.Entries) {
		return false
	}
	for i := range this.Entries {
		if !this.Entries[i].Equal(that1.Entries[i]) {
			return false
		}
	}
	if this.SandboxId != that1.SandboxId {
		return false
	}
	return true
}
func (this *NamePair) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamePair)
	if !ok {
		that2, ok := that.(NamePair)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Source != that1.Source {
		return false
	}
	if this.Destination != that1.Destination {
		return false
	}
	return true
}
func (this *RepeatedNamePairEntries) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RepeatedNamePairEntries)
	if !ok {
		that2, ok := that.(RepeatedNamePairEntries)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Entries) != len(that1.Entries) {
		return false
	}
	for i := range this.Entries {
		if !this.Entries[i].Equal(that1.Entries[i]) {
			return false
		}
	}
	if this.SandboxId != that1.SandboxId {
		return false
	}
	return true
}
func (this *RepeatedStringEntries) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RepeatedStringEntries)
	if !ok {
		that2, ok := that.(RepeatedStringEntries)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Entries) != len(that1.Entries) {
		return false
	}
	for i := range this.Entries {
		if this.Entries[i] != that1.Entries[i] {
			return false
		}
	}
	return true
}
func (m *LocalEnvironment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalEnvironment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Empty {
		dAtA[i] = 0x8
		i++
		if m.Empty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Variable) > 0 {
		for _, msg := range m.Variable {
			dAtA[i] = 0x12
			i++
			i = encodeVarintLocal(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LocalEnvironment_Variable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalEnvironment_Variable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.Expand {
		dAtA[i] = 0x18
		i++
		if m.Expand {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *LocalExecutionParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalExecutionParameters) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApplicationName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.ApplicationName)))
		i += copy(dAtA[i:], m.ApplicationName)
	}
	if len(m.CommandLine) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.CommandLine)))
		i += copy(dAtA[i:], m.CommandLine)
	}
	if len(m.CurrentDirectory) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.CurrentDirectory)))
		i += copy(dAtA[i:], m.CurrentDirectory)
	}
	if m.TimeLimitMicros != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.TimeLimitMicros))
	}
	if m.MemoryLimit != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.MemoryLimit))
	}
	if m.CheckIdleness {
		dAtA[i] = 0x30
		i++
		if m.CheckIdleness {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Environment != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.Environment.Size()))
		n1, err := m.Environment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.RestrictUi {
		dAtA[i] = 0x40
		i++
		if m.RestrictUi {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NoJob {
		dAtA[i] = 0x48
		i++
		if m.NoJob {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ProcessLimit != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.ProcessLimit))
	}
	if m.StdIn != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.StdIn.Size()))
		n2, err := m.StdIn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.StdOut != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.StdOut.Size()))
		n3, err := m.StdOut.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.StdErr != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.StdErr.Size()))
		n4, err := m.StdErr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.CommandLineParameters) > 0 {
		for _, s := range m.CommandLineParameters {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.SandboxId) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.SandboxId)))
		i += copy(dAtA[i:], m.SandboxId)
	}
	if m.JoinStdoutStderr {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.JoinStdoutStderr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.KernelTimeLimitMicros != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.KernelTimeLimitMicros))
	}
	if m.WallTimeLimitMicros != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.WallTimeLimitMicros))
	}
	return i, nil
}

func (m *LocalExecuteConnected) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalExecuteConnected) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.First != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.First.Size()))
		n5, err := m.First.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Second != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.Second.Size()))
		n6, err := m.Second.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *LocalExecutionResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalExecutionResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.Flags.Size()))
		n7, err := m.Flags.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Time != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.Time.Size()))
		n8, err := m.Time.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Memory != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.Memory))
	}
	if m.ReturnCode != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.ReturnCode))
	}
	if m.StdOut != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.StdOut.Size()))
		n9, err := m.StdOut.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.StdErr != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.StdErr.Size()))
		n10, err := m.StdErr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.TotalProcesses != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.TotalProcesses))
	}
	if m.KillSignal != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.KillSignal))
	}
	if m.StopSignal != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.StopSignal))
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *LocalExecuteConnectedResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalExecuteConnectedResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.First != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.First.Size()))
		n11, err := m.First.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Second != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.Second.Size()))
		n12, err := m.Second.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *LocalExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalExecution) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Parameters != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.Parameters.Size()))
		n13, err := m.Parameters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Result != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.Result.Size()))
		n14, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *BinaryTypeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinaryTypeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pathname) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Pathname)))
		i += copy(dAtA[i:], m.Pathname)
	}
	return i, nil
}

func (m *BinaryTypeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinaryTypeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Failure {
		dAtA[i] = 0x8
		i++
		if m.Failure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Result != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *ClearSandboxRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearSandboxRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sandbox) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Sandbox)))
		i += copy(dAtA[i:], m.Sandbox)
	}
	return i, nil
}

func (m *IdentifyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdentifyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ContesterId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.ContesterId)))
		i += copy(dAtA[i:], m.ContesterId)
	}
	return i, nil
}

func (m *SandboxLocations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SandboxLocations) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Compile) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Compile)))
		i += copy(dAtA[i:], m.Compile)
	}
	if len(m.Run) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Run)))
		i += copy(dAtA[i:], m.Run)
	}
	return i, nil
}

func (m *IdentifyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdentifyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InvokerId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.InvokerId)))
		i += copy(dAtA[i:], m.InvokerId)
	}
	if len(m.Sandboxes) > 0 {
		for _, msg := range m.Sandboxes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintLocal(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Environment != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.Environment.Size()))
		n15, err := m.Environment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if len(m.PathSeparator) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.PathSeparator)))
		i += copy(dAtA[i:], m.PathSeparator)
	}
	if len(m.Disks) > 0 {
		for _, s := range m.Disks {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ProgramFiles) > 0 {
		for _, s := range m.ProgramFiles {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *FileStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileStat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.IsDirectory {
		dAtA[i] = 0x10
		i++
		if m.IsDirectory {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.Size_))
	}
	if len(m.Checksum) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Checksum)))
		i += copy(dAtA[i:], m.Checksum)
	}
	return i, nil
}

func (m *StatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		for _, s := range m.Name {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.SandboxId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.SandboxId)))
		i += copy(dAtA[i:], m.SandboxId)
	}
	if m.Expand {
		dAtA[i] = 0x18
		i++
		if m.Expand {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CalculateChecksum {
		dAtA[i] = 0x20
		i++
		if m.CalculateChecksum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FileStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintLocal(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *EmptyMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmptyMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CopyOperation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CopyOperation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LocalFileName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.LocalFileName)))
		i += copy(dAtA[i:], m.LocalFileName)
	}
	if len(m.RemoteLocation) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.RemoteLocation)))
		i += copy(dAtA[i:], m.RemoteLocation)
	}
	if m.Upload {
		dAtA[i] = 0x18
		i++
		if m.Upload {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Checksum) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Checksum)))
		i += copy(dAtA[i:], m.Checksum)
	}
	if len(m.ModuleType) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.ModuleType)))
		i += copy(dAtA[i:], m.ModuleType)
	}
	if len(m.AuthorizationToken) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.AuthorizationToken)))
		i += copy(dAtA[i:], m.AuthorizationToken)
	}
	return i, nil
}

func (m *CopyOperations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CopyOperations) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintLocal(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SandboxId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.SandboxId)))
		i += copy(dAtA[i:], m.SandboxId)
	}
	return i, nil
}

func (m *NamePair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamePair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Destination) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Destination)))
		i += copy(dAtA[i:], m.Destination)
	}
	return i, nil
}

func (m *RepeatedNamePairEntries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepeatedNamePairEntries) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintLocal(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SandboxId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.SandboxId)))
		i += copy(dAtA[i:], m.SandboxId)
	}
	return i, nil
}

func (m *RepeatedStringEntries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepeatedStringEntries) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, s := range m.Entries {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeVarintLocal(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *LocalEnvironment) Size() (n int) {
	var l int
	_ = l
	if m.Empty {
		n += 2
	}
	if len(m.Variable) > 0 {
		for _, e := range m.Variable {
			l = e.Size()
			n += 1 + l + sovLocal(uint64(l))
		}
	}
	return n
}

func (m *LocalEnvironment_Variable) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.Expand {
		n += 2
	}
	return n
}

func (m *LocalExecutionParameters) Size() (n int) {
	var l int
	_ = l
	l = len(m.ApplicationName)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	l = len(m.CommandLine)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	l = len(m.CurrentDirectory)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.TimeLimitMicros != 0 {
		n += 1 + sovLocal(uint64(m.TimeLimitMicros))
	}
	if m.MemoryLimit != 0 {
		n += 1 + sovLocal(uint64(m.MemoryLimit))
	}
	if m.CheckIdleness {
		n += 2
	}
	if m.Environment != nil {
		l = m.Environment.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.RestrictUi {
		n += 2
	}
	if m.NoJob {
		n += 2
	}
	if m.ProcessLimit != 0 {
		n += 1 + sovLocal(uint64(m.ProcessLimit))
	}
	if m.StdIn != nil {
		l = m.StdIn.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.StdOut != nil {
		l = m.StdOut.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.StdErr != nil {
		l = m.StdErr.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if len(m.CommandLineParameters) > 0 {
		for _, s := range m.CommandLineParameters {
			l = len(s)
			n += 2 + l + sovLocal(uint64(l))
		}
	}
	l = len(m.SandboxId)
	if l > 0 {
		n += 2 + l + sovLocal(uint64(l))
	}
	if m.JoinStdoutStderr {
		n += 3
	}
	if m.KernelTimeLimitMicros != 0 {
		n += 2 + sovLocal(uint64(m.KernelTimeLimitMicros))
	}
	if m.WallTimeLimitMicros != 0 {
		n += 2 + sovLocal(uint64(m.WallTimeLimitMicros))
	}
	return n
}

func (m *LocalExecuteConnected) Size() (n int) {
	var l int
	_ = l
	if m.First != nil {
		l = m.First.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.Second != nil {
		l = m.Second.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	return n
}

func (m *LocalExecutionResult) Size() (n int) {
	var l int
	_ = l
	if m.Flags != nil {
		l = m.Flags.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.Memory != 0 {
		n += 1 + sovLocal(uint64(m.Memory))
	}
	if m.ReturnCode != 0 {
		n += 1 + sovLocal(uint64(m.ReturnCode))
	}
	if m.StdOut != nil {
		l = m.StdOut.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.StdErr != nil {
		l = m.StdErr.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.TotalProcesses != 0 {
		n += 1 + sovLocal(uint64(m.TotalProcesses))
	}
	if m.KillSignal != 0 {
		n += 1 + sovLocal(uint64(m.KillSignal))
	}
	if m.StopSignal != 0 {
		n += 1 + sovLocal(uint64(m.StopSignal))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	return n
}

func (m *LocalExecuteConnectedResult) Size() (n int) {
	var l int
	_ = l
	if m.First != nil {
		l = m.First.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.Second != nil {
		l = m.Second.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	return n
}

func (m *LocalExecution) Size() (n int) {
	var l int
	_ = l
	if m.Parameters != nil {
		l = m.Parameters.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	return n
}

func (m *BinaryTypeRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Pathname)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	return n
}

func (m *BinaryTypeResponse) Size() (n int) {
	var l int
	_ = l
	if m.Failure {
		n += 2
	}
	if m.Result != 0 {
		n += 1 + sovLocal(uint64(m.Result))
	}
	return n
}

func (m *ClearSandboxRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Sandbox)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	return n
}

func (m *IdentifyRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ContesterId)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	return n
}

func (m *SandboxLocations) Size() (n int) {
	var l int
	_ = l
	l = len(m.Compile)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	l = len(m.Run)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	return n
}

func (m *IdentifyResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.InvokerId)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if len(m.Sandboxes) > 0 {
		for _, e := range m.Sandboxes {
			l = e.Size()
			n += 1 + l + sovLocal(uint64(l))
		}
	}
	if m.Environment != nil {
		l = m.Environment.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	l = len(m.PathSeparator)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if len(m.Disks) > 0 {
		for _, s := range m.Disks {
			l = len(s)
			n += 1 + l + sovLocal(uint64(l))
		}
	}
	if len(m.ProgramFiles) > 0 {
		for _, s := range m.ProgramFiles {
			l = len(s)
			n += 1 + l + sovLocal(uint64(l))
		}
	}
	return n
}

func (m *FileStat) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.IsDirectory {
		n += 2
	}
	if m.Size_ != 0 {
		n += 1 + sovLocal(uint64(m.Size_))
	}
	l = len(m.Checksum)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	return n
}

func (m *StatRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Name) > 0 {
		for _, s := range m.Name {
			l = len(s)
			n += 1 + l + sovLocal(uint64(l))
		}
	}
	l = len(m.SandboxId)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.Expand {
		n += 2
	}
	if m.CalculateChecksum {
		n += 2
	}
	return n
}

func (m *FileStats) Size() (n int) {
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLocal(uint64(l))
		}
	}
	return n
}

func (m *GetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	return n
}

func (m *EmptyMessage) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CopyOperation) Size() (n int) {
	var l int
	_ = l
	l = len(m.LocalFileName)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	l = len(m.RemoteLocation)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.Upload {
		n += 2
	}
	l = len(m.Checksum)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	l = len(m.ModuleType)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	l = len(m.AuthorizationToken)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	return n
}

func (m *CopyOperations) Size() (n int) {
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLocal(uint64(l))
		}
	}
	l = len(m.SandboxId)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	return n
}

func (m *NamePair) Size() (n int) {
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	return n
}

func (m *RepeatedNamePairEntries) Size() (n int) {
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLocal(uint64(l))
		}
	}
	l = len(m.SandboxId)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	return n
}

func (m *RepeatedStringEntries) Size() (n int) {
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, s := range m.Entries {
			l = len(s)
			n += 1 + l + sovLocal(uint64(l))
		}
	}
	return n
}

func sovLocal(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozLocal(x uint64) (n int) {
	return sovLocal(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *LocalEnvironment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalEnvironment{`,
		`Empty:` + fmt.Sprintf("%v", this.Empty) + `,`,
		`Variable:` + strings.Replace(fmt.Sprintf("%v", this.Variable), "LocalEnvironment_Variable", "LocalEnvironment_Variable", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalEnvironment_Variable) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalEnvironment_Variable{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Expand:` + fmt.Sprintf("%v", this.Expand) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalExecutionParameters) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalExecutionParameters{`,
		`ApplicationName:` + fmt.Sprintf("%v", this.ApplicationName) + `,`,
		`CommandLine:` + fmt.Sprintf("%v", this.CommandLine) + `,`,
		`CurrentDirectory:` + fmt.Sprintf("%v", this.CurrentDirectory) + `,`,
		`TimeLimitMicros:` + fmt.Sprintf("%v", this.TimeLimitMicros) + `,`,
		`MemoryLimit:` + fmt.Sprintf("%v", this.MemoryLimit) + `,`,
		`CheckIdleness:` + fmt.Sprintf("%v", this.CheckIdleness) + `,`,
		`Environment:` + strings.Replace(fmt.Sprintf("%v", this.Environment), "LocalEnvironment", "LocalEnvironment", 1) + `,`,
		`RestrictUi:` + fmt.Sprintf("%v", this.RestrictUi) + `,`,
		`NoJob:` + fmt.Sprintf("%v", this.NoJob) + `,`,
		`ProcessLimit:` + fmt.Sprintf("%v", this.ProcessLimit) + `,`,
		`StdIn:` + strings.Replace(fmt.Sprintf("%v", this.StdIn), "RedirectParameters", "RedirectParameters", 1) + `,`,
		`StdOut:` + strings.Replace(fmt.Sprintf("%v", this.StdOut), "RedirectParameters", "RedirectParameters", 1) + `,`,
		`StdErr:` + strings.Replace(fmt.Sprintf("%v", this.StdErr), "RedirectParameters", "RedirectParameters", 1) + `,`,
		`CommandLineParameters:` + fmt.Sprintf("%v", this.CommandLineParameters) + `,`,
		`SandboxId:` + fmt.Sprintf("%v", this.SandboxId) + `,`,
		`JoinStdoutStderr:` + fmt.Sprintf("%v", this.JoinStdoutStderr) + `,`,
		`KernelTimeLimitMicros:` + fmt.Sprintf("%v", this.KernelTimeLimitMicros) + `,`,
		`WallTimeLimitMicros:` + fmt.Sprintf("%v", this.WallTimeLimitMicros) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalExecuteConnected) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalExecuteConnected{`,
		`First:` + strings.Replace(fmt.Sprintf("%v", this.First), "LocalExecutionParameters", "LocalExecutionParameters", 1) + `,`,
		`Second:` + strings.Replace(fmt.Sprintf("%v", this.Second), "LocalExecutionParameters", "LocalExecutionParameters", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalExecutionResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalExecutionResult{`,
		`Flags:` + strings.Replace(fmt.Sprintf("%v", this.Flags), "ExecutionResultFlags", "ExecutionResultFlags", 1) + `,`,
		`Time:` + strings.Replace(fmt.Sprintf("%v", this.Time), "ExecutionResultTime", "ExecutionResultTime", 1) + `,`,
		`Memory:` + fmt.Sprintf("%v", this.Memory) + `,`,
		`ReturnCode:` + fmt.Sprintf("%v", this.ReturnCode) + `,`,
		`StdOut:` + strings.Replace(fmt.Sprintf("%v", this.StdOut), "Blob", "Blob", 1) + `,`,
		`StdErr:` + strings.Replace(fmt.Sprintf("%v", this.StdErr), "Blob", "Blob", 1) + `,`,
		`TotalProcesses:` + fmt.Sprintf("%v", this.TotalProcesses) + `,`,
		`KillSignal:` + fmt.Sprintf("%v", this.KillSignal) + `,`,
		`StopSignal:` + fmt.Sprintf("%v", this.StopSignal) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalExecuteConnectedResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalExecuteConnectedResult{`,
		`First:` + strings.Replace(fmt.Sprintf("%v", this.First), "LocalExecutionResult", "LocalExecutionResult", 1) + `,`,
		`Second:` + strings.Replace(fmt.Sprintf("%v", this.Second), "LocalExecutionResult", "LocalExecutionResult", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalExecution) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalExecution{`,
		`Parameters:` + strings.Replace(fmt.Sprintf("%v", this.Parameters), "LocalExecutionParameters", "LocalExecutionParameters", 1) + `,`,
		`Result:` + strings.Replace(fmt.Sprintf("%v", this.Result), "LocalExecutionResult", "LocalExecutionResult", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BinaryTypeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BinaryTypeRequest{`,
		`Pathname:` + fmt.Sprintf("%v", this.Pathname) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BinaryTypeResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BinaryTypeResponse{`,
		`Failure:` + fmt.Sprintf("%v", this.Failure) + `,`,
		`Result:` + fmt.Sprintf("%v", this.Result) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClearSandboxRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClearSandboxRequest{`,
		`Sandbox:` + fmt.Sprintf("%v", this.Sandbox) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IdentifyRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IdentifyRequest{`,
		`ContesterId:` + fmt.Sprintf("%v", this.ContesterId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SandboxLocations) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SandboxLocations{`,
		`Compile:` + fmt.Sprintf("%v", this.Compile) + `,`,
		`Run:` + fmt.Sprintf("%v", this.Run) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IdentifyResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IdentifyResponse{`,
		`InvokerId:` + fmt.Sprintf("%v", this.InvokerId) + `,`,
		`Sandboxes:` + strings.Replace(fmt.Sprintf("%v", this.Sandboxes), "SandboxLocations", "SandboxLocations", 1) + `,`,
		`Environment:` + strings.Replace(fmt.Sprintf("%v", this.Environment), "LocalEnvironment", "LocalEnvironment", 1) + `,`,
		`Platform:` + fmt.Sprintf("%v", this.Platform) + `,`,
		`PathSeparator:` + fmt.Sprintf("%v", this.PathSeparator) + `,`,
		`Disks:` + fmt.Sprintf("%v", this.Disks) + `,`,
		`ProgramFiles:` + fmt.Sprintf("%v", this.ProgramFiles) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FileStat) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FileStat{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`IsDirectory:` + fmt.Sprintf("%v", this.IsDirectory) + `,`,
		`Size_:` + fmt.Sprintf("%v", this.Size_) + `,`,
		`Checksum:` + fmt.Sprintf("%v", this.Checksum) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StatRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StatRequest{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`SandboxId:` + fmt.Sprintf("%v", this.SandboxId) + `,`,
		`Expand:` + fmt.Sprintf("%v", this.Expand) + `,`,
		`CalculateChecksum:` + fmt.Sprintf("%v", this.CalculateChecksum) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FileStats) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FileStats{`,
		`Entries:` + strings.Replace(fmt.Sprintf("%v", this.Entries), "FileStat", "FileStat", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetRequest{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EmptyMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EmptyMessage{`,
		`}`,
	}, "")
	return s
}
func (this *CopyOperation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CopyOperation{`,
		`LocalFileName:` + fmt.Sprintf("%v", this.LocalFileName) + `,`,
		`RemoteLocation:` + fmt.Sprintf("%v", this.RemoteLocation) + `,`,
		`Upload:` + fmt.Sprintf("%v", this.Upload) + `,`,
		`Checksum:` + fmt.Sprintf("%v", this.Checksum) + `,`,
		`ModuleType:` + fmt.Sprintf("%v", this.ModuleType) + `,`,
		`AuthorizationToken:` + fmt.Sprintf("%v", this.AuthorizationToken) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CopyOperations) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CopyOperations{`,
		`Entries:` + strings.Replace(fmt.Sprintf("%v", this.Entries), "CopyOperation", "CopyOperation", 1) + `,`,
		`SandboxId:` + fmt.Sprintf("%v", this.SandboxId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamePair) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NamePair{`,
		`Source:` + fmt.Sprintf("%v", this.Source) + `,`,
		`Destination:` + fmt.Sprintf("%v", this.Destination) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RepeatedNamePairEntries) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RepeatedNamePairEntries{`,
		`Entries:` + strings.Replace(fmt.Sprintf("%v", this.Entries), "NamePair", "NamePair", 1) + `,`,
		`SandboxId:` + fmt.Sprintf("%v", this.SandboxId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RepeatedStringEntries) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RepeatedStringEntries{`,
		`Entries:` + fmt.Sprintf("%v", this.Entries) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringLocal(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *LocalEnvironment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalEnvironment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalEnvironment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Empty = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variable = append(m.Variable, &LocalEnvironment_Variable{})
			if err := m.Variable[len(m.Variable)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalEnvironment_Variable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Variable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Variable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expand", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Expand = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalExecutionParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalExecutionParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalExecutionParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandLine", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommandLine = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentDirectory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentDirectory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeLimitMicros", wireType)
			}
			m.TimeLimitMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeLimitMicros |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryLimit", wireType)
			}
			m.MemoryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryLimit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckIdleness", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CheckIdleness = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Environment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Environment == nil {
				m.Environment = &LocalEnvironment{}
			}
			if err := m.Environment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestrictUi", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RestrictUi = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoJob", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoJob = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessLimit", wireType)
			}
			m.ProcessLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessLimit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StdIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StdIn == nil {
				m.StdIn = &RedirectParameters{}
			}
			if err := m.StdIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StdOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StdOut == nil {
				m.StdOut = &RedirectParameters{}
			}
			if err := m.StdOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StdErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StdErr == nil {
				m.StdErr = &RedirectParameters{}
			}
			if err := m.StdErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandLineParameters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommandLineParameters = append(m.CommandLineParameters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SandboxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SandboxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinStdoutStderr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.JoinStdoutStderr = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelTimeLimitMicros", wireType)
			}
			m.KernelTimeLimitMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KernelTimeLimitMicros |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallTimeLimitMicros", wireType)
			}
			m.WallTimeLimitMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WallTimeLimitMicros |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalExecuteConnected) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalExecuteConnected: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalExecuteConnected: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field First", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.First == nil {
				m.First = &LocalExecutionParameters{}
			}
			if err := m.First.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Second", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Second == nil {
				m.Second = &LocalExecutionParameters{}
			}
			if err := m.Second.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalExecutionResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalExecutionResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalExecutionResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Flags == nil {
				m.Flags = &ExecutionResultFlags{}
			}
			if err := m.Flags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &ExecutionResultTime{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnCode", wireType)
			}
			m.ReturnCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReturnCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StdOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StdOut == nil {
				m.StdOut = &Blob{}
			}
			if err := m.StdOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StdErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StdErr == nil {
				m.StdErr = &Blob{}
			}
			if err := m.StdErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalProcesses", wireType)
			}
			m.TotalProcesses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalProcesses |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillSignal", wireType)
			}
			m.KillSignal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KillSignal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopSignal", wireType)
			}
			m.StopSignal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StopSignal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalExecuteConnectedResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalExecuteConnectedResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalExecuteConnectedResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field First", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.First == nil {
				m.First = &LocalExecutionResult{}
			}
			if err := m.First.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Second", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Second == nil {
				m.Second = &LocalExecutionResult{}
			}
			if err := m.Second.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parameters == nil {
				m.Parameters = &LocalExecutionParameters{}
			}
			if err := m.Parameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &LocalExecutionResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinaryTypeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinaryTypeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinaryTypeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pathname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pathname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinaryTypeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinaryTypeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinaryTypeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failure = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (BinaryTypeResponse_Win32BinaryType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearSandboxRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearSandboxRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearSandboxRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sandbox", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sandbox = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdentifyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdentifyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdentifyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContesterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContesterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SandboxLocations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SandboxLocations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SandboxLocations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Compile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Run", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Run = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdentifyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdentifyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdentifyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvokerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvokerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sandboxes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sandboxes = append(m.Sandboxes, &SandboxLocations{})
			if err := m.Sandboxes[len(m.Sandboxes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Environment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Environment == nil {
				m.Environment = &LocalEnvironment{}
			}
			if err := m.Environment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathSeparator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathSeparator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disks", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Disks = append(m.Disks, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramFiles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramFiles = append(m.ProgramFiles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDirectory", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDirectory = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checksum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SandboxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SandboxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expand", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Expand = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CalculateChecksum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CalculateChecksum = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &FileStat{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmptyMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmptyMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmptyMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CopyOperation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CopyOperation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CopyOperation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalFileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalFileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteLocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Upload = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checksum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizationToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorizationToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CopyOperations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CopyOperations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CopyOperations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &CopyOperation{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SandboxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SandboxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamePair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamePair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamePair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepeatedNamePairEntries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepeatedNamePairEntries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepeatedNamePairEntries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &NamePair{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SandboxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SandboxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepeatedStringEntries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepeatedStringEntries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepeatedStringEntries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLocal(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthLocal
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLocal
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLocal(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLocal = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLocal   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/contester/runlib/contester_proto/Local.proto", fileDescriptorLocal)
}

var fileDescriptorLocal = []byte{
	// 1584 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0xcd, 0x73, 0x1b, 0xb7,
	0x15, 0xf7, 0x8a, 0x1f, 0x22, 0x1f, 0xc5, 0x0f, 0xc1, 0x56, 0xb2, 0x75, 0x1b, 0x96, 0xde, 0xd4,
	0x8d, 0x92, 0x36, 0xd4, 0x84, 0xca, 0x38, 0x9d, 0xa4, 0x5f, 0x91, 0x2c, 0x77, 0xd8, 0x3a, 0x91,
	0x66, 0xe9, 0xd6, 0xed, 0x69, 0x67, 0xb9, 0x0b, 0xd1, 0x88, 0x76, 0x81, 0x0d, 0x80, 0x75, 0xcd,
	0x9c, 0x7a, 0xeb, 0xbf, 0xd0, 0x8f, 0x63, 0xa7, 0xd3, 0xfe, 0x01, 0x3d, 0xf7, 0xdc, 0x63, 0x8f,
	0x39, 0xb6, 0xea, 0x4c, 0xff, 0x8e, 0x0e, 0xb0, 0x00, 0xb9, 0x24, 0xed, 0x4a, 0xca, 0x89, 0xfb,
	0x7e, 0x78, 0x3f, 0xbc, 0x87, 0x87, 0x1f, 0x80, 0x47, 0xf8, 0x60, 0x46, 0xe4, 0xb3, 0x7c, 0x3a,
	0x8c, 0x58, 0x7a, 0x10, 0x31, 0x2a, 0xb1, 0x90, 0x98, 0x1f, 0xf0, 0x9c, 0x26, 0x64, 0xba, 0x04,
	0x82, 0x8c, 0x33, 0xc9, 0x0e, 0x1e, 0xb3, 0x28, 0x4c, 0x86, 0xfa, 0x1b, 0x75, 0x17, 0x83, 0x05,
	0x70, 0xf7, 0x46, 0x33, 0x1d, 0x25, 0x6c, 0x2a, 0x0c, 0xf1, 0xa3, 0x9b, 0x10, 0x4f, 0x5e, 0xe0,
	0x28, 0x97, 0x84, 0x51, 0x43, 0x7e, 0xb7, 0x44, 0x9e, 0xb1, 0x19, 0x3b, 0xd0, 0xf0, 0x34, 0x3f,
	0xd7, 0x56, 0xc1, 0x51, 0x5f, 0x85, 0xbb, 0xf7, 0x77, 0x07, 0x7a, 0x7a, 0x15, 0x27, 0xf4, 0x39,
	0xe1, 0x8c, 0xa6, 0x98, 0x4a, 0x74, 0x07, 0x6a, 0x38, 0xcd, 0xe4, 0xdc, 0x75, 0x06, 0xce, 0x7e,
	0xc3, 0x2f, 0x0c, 0xf4, 0x08, 0x1a, 0xcf, 0x43, 0x4e, 0xc2, 0x69, 0x82, 0xdd, 0xad, 0x41, 0x65,
	0xbf, 0x35, 0x7a, 0x67, 0xb8, 0xb6, 0xe6, 0xe1, 0xfa, 0x54, 0xc3, 0x5f, 0x18, 0x86, 0xbf, 0xe0,
	0xde, 0x7d, 0x0c, 0x0d, 0x8b, 0x22, 0x04, 0x55, 0x1a, 0xa6, 0x58, 0x07, 0x6a, 0xfa, 0xfa, 0x5b,
	0x45, 0x7f, 0x1e, 0x26, 0xb9, 0x0a, 0xa2, 0xc0, 0xc2, 0x40, 0xaf, 0x41, 0x1d, 0xbf, 0xc8, 0x42,
	0x1a, 0xbb, 0x15, 0x9d, 0x94, 0xb1, 0xbc, 0x2f, 0xeb, 0xe0, 0x16, 0x51, 0x6d, 0x21, 0xce, 0x42,
	0x1e, 0xa6, 0x58, 0x62, 0x2e, 0xd0, 0xdb, 0xd0, 0x0b, 0xb3, 0x2c, 0x21, 0x51, 0xa8, 0x06, 0x82,
	0x52, 0xa8, 0x6e, 0x09, 0xff, 0x54, 0x45, 0xbd, 0x07, 0x3b, 0x11, 0x4b, 0xd3, 0x90, 0xc6, 0x41,
	0x42, 0xa8, 0x0d, 0xde, 0x32, 0xd8, 0x63, 0x42, 0x31, 0xfa, 0x0e, 0xec, 0x46, 0x39, 0xe7, 0x98,
	0xca, 0x20, 0x26, 0x1c, 0x47, 0x92, 0xf1, 0xb9, 0xce, 0xa6, 0xe9, 0xf7, 0xcc, 0xc0, 0x43, 0x8b,
	0xa3, 0x77, 0x60, 0x57, 0x92, 0x14, 0x07, 0x09, 0x49, 0x89, 0x0c, 0x52, 0x12, 0x71, 0x26, 0xdc,
	0xea, 0xc0, 0xd9, 0xaf, 0xfa, 0x5d, 0x35, 0xf0, 0x58, 0xe1, 0x9f, 0x68, 0x58, 0xc5, 0x4e, 0x71,
	0xca, 0xf8, 0xbc, 0xf0, 0x76, 0x6b, 0xda, 0xad, 0x55, 0x60, 0xda, 0x11, 0xdd, 0x87, 0x4e, 0xf4,
	0x0c, 0x47, 0x17, 0x01, 0x89, 0x13, 0x4c, 0xb1, 0x10, 0x6e, 0x5d, 0x97, 0xa1, 0xad, 0xd1, 0xb1,
	0x01, 0xd1, 0x31, 0xb4, 0xf0, 0xb2, 0xfa, 0xee, 0xf6, 0xc0, 0xd9, 0x6f, 0x8d, 0xee, 0x5d, 0xb9,
	0x4d, 0x7e, 0x99, 0x85, 0xbe, 0x09, 0x2d, 0x8e, 0x85, 0xe4, 0x24, 0x92, 0x41, 0x4e, 0xdc, 0x86,
	0x0e, 0x04, 0x16, 0xfa, 0x39, 0x41, 0x7b, 0x50, 0xa7, 0x2c, 0xf8, 0x8c, 0x4d, 0xdd, 0x66, 0x21,
	0x10, 0xca, 0x7e, 0xca, 0xa6, 0xe8, 0x4d, 0x68, 0x67, 0x9c, 0x45, 0x58, 0x08, 0xb3, 0x0e, 0x18,
	0x38, 0xfb, 0x6d, 0x7f, 0xc7, 0x80, 0xc5, 0x42, 0x3e, 0x84, 0xba, 0x90, 0x71, 0x40, 0xa8, 0xbb,
	0xa3, 0x93, 0x7b, 0x73, 0x23, 0x39, 0x1f, 0x17, 0xd5, 0x5d, 0xee, 0xa3, 0x5f, 0x13, 0x32, 0x1e,
	0x53, 0xf4, 0x7d, 0xd8, 0x56, 0x5c, 0x96, 0x4b, 0xb7, 0x7d, 0x7d, 0xb2, 0x8a, 0x77, 0x9a, 0x4b,
	0xcb, 0xc6, 0x9c, 0xbb, 0x9d, 0x9b, 0xb1, 0x4f, 0x38, 0x47, 0x0f, 0xe0, 0xf5, 0xb2, 0x3e, 0x82,
	0x6c, 0xe1, 0xe2, 0xf6, 0x06, 0x95, 0xfd, 0xa6, 0xbf, 0x57, 0x92, 0x4a, 0x49, 0x82, 0x6f, 0x00,
	0x88, 0x90, 0xc6, 0x53, 0xf6, 0x22, 0x20, 0xb1, 0xbb, 0xab, 0xd5, 0xd2, 0x34, 0xc8, 0x38, 0x46,
	0xdf, 0x05, 0xf4, 0x19, 0x23, 0x34, 0x10, 0x32, 0x66, 0xb9, 0x54, 0x3f, 0x2a, 0x3f, 0xa4, 0xcb,
	0xda, 0x53, 0x23, 0x13, 0x3d, 0x30, 0xd1, 0x38, 0xfa, 0x00, 0xdc, 0x0b, 0xcc, 0x29, 0x4e, 0x82,
	0x4d, 0x6d, 0xdd, 0xd6, 0xa2, 0xd9, 0x2b, 0xc6, 0x9f, 0xac, 0x29, 0xec, 0x10, 0x5e, 0xfb, 0x75,
	0x98, 0xbc, 0x8c, 0x76, 0x47, 0xd3, 0x6e, 0xab, 0xd1, 0x35, 0x92, 0xf7, 0x47, 0x07, 0xf6, 0x4a,
	0x47, 0x0b, 0x1f, 0x33, 0x4a, 0x71, 0x24, 0x71, 0x8c, 0x7e, 0x04, 0xb5, 0x73, 0xc2, 0x85, 0xd4,
	0x87, 0xa9, 0x35, 0x7a, 0xfb, 0x15, 0x02, 0xdb, 0x3c, 0x91, 0x7e, 0xc1, 0x43, 0x1f, 0x43, 0x5d,
	0xe0, 0x88, 0xd1, 0x58, 0x9f, 0xb3, 0x1b, 0xcd, 0x60, 0x88, 0xde, 0x5f, 0x2a, 0x70, 0x67, 0xd5,
	0xc9, 0xc7, 0x22, 0x4f, 0x24, 0xfa, 0x08, 0x6a, 0xe7, 0x49, 0x38, 0x13, 0x26, 0xb9, 0xfb, 0x1b,
	0x53, 0xaf, 0x11, 0x1e, 0x29, 0x67, 0xbf, 0xe0, 0xa0, 0xef, 0x41, 0x55, 0xd5, 0xc8, 0xa4, 0xf5,
	0xad, 0xab, 0xb8, 0xaa, 0x64, 0xbe, 0x66, 0xa8, 0x0b, 0xaa, 0x38, 0xb0, 0xfa, 0x4a, 0xa8, 0xfa,
	0xc6, 0x2a, 0x4e, 0x93, 0xcc, 0x39, 0x0d, 0x22, 0x16, 0x63, 0x7d, 0x05, 0xb4, 0xd5, 0x69, 0x52,
	0xd0, 0x31, 0x8b, 0x31, 0x1a, 0x2e, 0x55, 0x5d, 0xd3, 0x51, 0xf7, 0x36, 0xa2, 0xaa, 0xd7, 0x61,
	0xa1, 0xe3, 0xe1, 0x52, 0xc7, 0xf5, 0xab, 0xfc, 0x95, 0x72, 0xdf, 0x82, 0xae, 0x64, 0x32, 0x4c,
	0x02, 0x73, 0x0e, 0xb1, 0xd0, 0xf7, 0x42, 0xd5, 0xef, 0x68, 0xf8, 0xcc, 0xa2, 0x2a, 0xd3, 0x0b,
	0x92, 0x24, 0x81, 0x20, 0x33, 0x1a, 0x26, 0xfa, 0xdc, 0xd7, 0x7c, 0x50, 0xd0, 0x44, 0x23, 0xca,
	0x41, 0x48, 0x96, 0x59, 0x87, 0x66, 0xe1, 0xa0, 0x20, 0xe3, 0xa0, 0x1e, 0x0e, 0xce, 0x19, 0xd7,
	0x27, 0xbf, 0xe9, 0x17, 0x86, 0xf7, 0x7b, 0x07, 0xbe, 0xfe, 0x52, 0x1d, 0x95, 0x36, 0xac, 0xa4,
	0xa6, 0xfb, 0x57, 0x68, 0xa1, 0x60, 0x59, 0x25, 0xfd, 0x60, 0x4d, 0x49, 0xd7, 0x64, 0x5b, 0x15,
	0xfd, 0xc1, 0x81, 0xce, 0xaa, 0x03, 0x1a, 0x03, 0x94, 0x0e, 0xf7, 0x8d, 0x15, 0x5e, 0x22, 0xab,
	0xe4, 0xb8, 0x8e, 0x77, 0xc3, 0xe4, 0x0a, 0x92, 0x77, 0x00, 0xbb, 0x47, 0x84, 0x86, 0x7c, 0xfe,
	0x64, 0x9e, 0x61, 0x1f, 0x7f, 0x9e, 0x63, 0x21, 0xd1, 0x5d, 0x68, 0x64, 0xa1, 0x7c, 0x56, 0x7a,
	0xcb, 0x16, 0xb6, 0xf7, 0xa7, 0x2d, 0x40, 0x65, 0x86, 0xc8, 0x18, 0x15, 0x18, 0xb9, 0xb0, 0x7d,
	0x1e, 0x92, 0x24, 0xe7, 0xd8, 0xbc, 0xe8, 0xd6, 0x44, 0x3f, 0x5b, 0x49, 0xb0, 0x33, 0x3a, 0xdc,
	0x94, 0xd2, 0xc6, 0x74, 0xc3, 0xa7, 0x84, 0x1e, 0x8e, 0x4a, 0xb8, 0x4d, 0xf7, 0xcf, 0x0e, 0x74,
	0xd7, 0xc6, 0xd0, 0x1d, 0xe8, 0x4d, 0x8e, 0x27, 0xc1, 0xe1, 0xe8, 0x68, 0xfc, 0x24, 0x38, 0x1a,
	0x7f, 0xfa, 0xb1, 0xff, 0xab, 0xde, 0x2d, 0x84, 0xa0, 0xa3, 0xd0, 0x87, 0xa7, 0x13, 0x8b, 0x39,
	0x16, 0x7b, 0x7a, 0xfa, 0xd4, 0x62, 0x5b, 0x16, 0x3b, 0x1b, 0x3f, 0xb2, 0x58, 0xc5, 0xce, 0x78,
	0x76, 0x3a, 0x19, 0xff, 0xd2, 0xa2, 0x55, 0x8b, 0x9e, 0x4e, 0x46, 0xef, 0x3d, 0xb0, 0x68, 0xcd,
	0xa2, 0x0f, 0xde, 0x2f, 0x45, 0xaf, 0x7b, 0x07, 0x70, 0xfb, 0x38, 0xc1, 0x21, 0x9f, 0x14, 0xb7,
	0xb0, 0x2d, 0xac, 0x0b, 0xdb, 0xe6, 0x5e, 0x36, 0x75, 0xb5, 0xa6, 0xf7, 0x3e, 0x74, 0xc7, 0x31,
	0xa6, 0x92, 0x9c, 0xcf, 0xad, 0xb3, 0x6e, 0x17, 0x6c, 0x27, 0x46, 0x62, 0xc3, 0x68, 0x2d, 0xb0,
	0x71, 0xec, 0xfd, 0x10, 0x7a, 0x26, 0x82, 0xda, 0x64, 0xb5, 0xbd, 0x42, 0xc5, 0x88, 0x58, 0x9a,
	0x91, 0xc4, 0xee, 0x9d, 0x35, 0x51, 0x0f, 0x2a, 0x3c, 0xa7, 0xa6, 0xed, 0x50, 0x9f, 0xde, 0xdf,
	0xb6, 0xa0, 0xb7, 0x0c, 0x6b, 0xb6, 0xf2, 0x0d, 0x00, 0x42, 0x9f, 0xb3, 0x8b, 0x72, 0xd4, 0xa6,
	0x41, 0xc6, 0xea, 0x62, 0xb6, 0x6f, 0x0b, 0x16, 0xa6, 0x49, 0xdb, 0x7c, 0xfd, 0xd7, 0xb3, 0xf2,
	0x97, 0x9c, 0xf5, 0x06, 0xa2, 0xf2, 0x95, 0x1a, 0x08, 0x25, 0xd1, 0x24, 0x94, 0xe7, 0x8c, 0xa7,
	0xfa, 0xbe, 0x53, 0x12, 0x35, 0xb6, 0x6a, 0x64, 0x94, 0x5c, 0x03, 0x81, 0xd5, 0x39, 0x91, 0x8c,
	0xeb, 0x4b, 0xaf, 0xe9, 0xb7, 0x15, 0x3a, 0xb1, 0xa0, 0xba, 0x49, 0x62, 0x22, 0x2e, 0x54, 0x9b,
	0xa3, 0x1e, 0xd7, 0xc2, 0x40, 0x1e, 0xa8, 0x66, 0x62, 0xc6, 0xc3, 0xf4, 0x11, 0x49, 0xf4, 0x3d,
	0xa6, 0x06, 0x57, 0x30, 0xef, 0x73, 0x68, 0xa8, 0x8f, 0x89, 0x0c, 0xe5, 0x4b, 0xdb, 0xcb, 0x7b,
	0xb0, 0x43, 0x44, 0xa9, 0x81, 0xdb, 0xd2, 0x27, 0xa2, 0x45, 0xc4, 0xb2, 0x77, 0x43, 0x50, 0x15,
	0xe4, 0x0b, 0x6c, 0x2e, 0x72, 0xfd, 0xad, 0xd6, 0xa4, 0x5b, 0x2d, 0x91, 0x2f, 0xd6, 0x64, 0x6d,
	0xef, 0xb7, 0x0e, 0xb4, 0x54, 0x3c, 0x2b, 0x8e, 0x65, 0xd8, 0xca, 0x22, 0xec, 0x6a, 0x1f, 0xb0,
	0xb5, 0xde, 0x07, 0xbc, 0xa2, 0xbd, 0x45, 0xef, 0x02, 0x8a, 0xc2, 0x24, 0xca, 0x93, 0x50, 0xe2,
	0x60, 0x25, 0x81, 0x86, 0xbf, 0xbb, 0x18, 0x39, 0xb6, 0x99, 0xfc, 0x18, 0x9a, 0x76, 0xf1, 0xea,
	0xd1, 0xdf, 0xc6, 0x54, 0x72, 0x82, 0x85, 0xce, 0xa4, 0x35, 0xfa, 0xda, 0xc6, 0x3e, 0x5a, 0x67,
	0xdf, 0x7a, 0x7a, 0x03, 0x80, 0x9f, 0xe0, 0x97, 0xac, 0x64, 0x51, 0x40, 0xaf, 0x03, 0x3b, 0x27,
	0xea, 0x0f, 0xc1, 0x27, 0x58, 0x88, 0x70, 0x86, 0xbd, 0xff, 0x3a, 0xd0, 0x3e, 0x66, 0xd9, 0xfc,
	0x34, 0xc3, 0x5c, 0x0b, 0x0a, 0x7d, 0x1b, 0xba, 0x89, 0x12, 0x48, 0x70, 0x4e, 0x12, 0x5c, 0xee,
	0xba, 0xdb, 0x1a, 0x56, 0x41, 0x75, 0xcf, 0xfd, 0x16, 0x74, 0x39, 0x4e, 0x99, 0xc4, 0x41, 0x62,
	0xb4, 0x68, 0x0a, 0xd3, 0x29, 0x60, 0xab, 0x50, 0x55, 0x9d, 0x3c, 0x4b, 0x58, 0xb8, 0xa8, 0x4e,
	0x61, 0xfd, 0xbf, 0x4d, 0x51, 0x8f, 0x55, 0xca, 0xe2, 0x3c, 0xc1, 0x81, 0x9c, 0x67, 0xd8, 0xa8,
	0x0c, 0x0a, 0x48, 0x5f, 0x4d, 0x07, 0x70, 0x3b, 0xcc, 0xe5, 0x33, 0xc6, 0xc9, 0x17, 0xc5, 0xdf,
	0x03, 0xc9, 0x2e, 0x30, 0xd5, 0x6f, 0x6a, 0xd3, 0x47, 0x2b, 0x43, 0x4f, 0xd4, 0x88, 0x47, 0xa0,
	0xb3, 0xb2, 0x4e, 0xd5, 0x2d, 0xac, 0x55, 0xb8, 0xbf, 0x51, 0xe1, 0x15, 0xc6, 0xa2, 0xcc, 0x57,
	0xc8, 0xc1, 0x7b, 0x08, 0x0d, 0x55, 0xa1, 0xb3, 0x90, 0x70, 0xb5, 0x78, 0xc1, 0x72, 0x1e, 0xd9,
	0x22, 0x1a, 0x0b, 0x0d, 0xa0, 0x15, 0x63, 0x21, 0x09, 0x2d, 0x57, 0xae, 0x0c, 0x79, 0x29, 0xbc,
	0xee, 0xe3, 0x0c, 0x87, 0x12, 0xc7, 0x76, 0xb6, 0x13, 0x13, 0xff, 0x1a, 0xda, 0xb0, 0x94, 0x6b,
	0x27, 0xfd, 0x1e, 0xec, 0xd9, 0x70, 0x13, 0xc9, 0x09, 0x9d, 0xd9, 0x60, 0xee, 0x6a, 0xb0, 0xe6,
	0x62, 0xc6, 0xa3, 0x0f, 0xbf, 0xfc, 0x77, 0xff, 0xd6, 0x6f, 0x2e, 0xfb, 0xce, 0x5f, 0x2f, 0xfb,
	0xce, 0x3f, 0x2e, 0xfb, 0xce, 0x3f, 0x2f, 0xfb, 0xce, 0xbf, 0x2e, 0xfb, 0xce, 0xef, 0xfe, 0xd3,
	0xbf, 0x05, 0xdf, 0x60, 0x7c, 0x36, 0x54, 0xcb, 0x99, 0xf1, 0x70, 0xbe, 0x9e, 0xdf, 0xb4, 0xae,
	0x7f, 0x0e, 0xff, 0x17, 0x00, 0x00, 0xff, 0xff, 0xaa, 0xca, 0x0b, 0x2f, 0xb2, 0x0f, 0x00, 0x00,
}
