// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: Local.proto

package contester_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type BinaryTypeResponse_Win32BinaryType int32

const (
	BinaryTypeResponse_SCS_32BIT_BINARY BinaryTypeResponse_Win32BinaryType = 0
	BinaryTypeResponse_SCS_DOS_BINARY   BinaryTypeResponse_Win32BinaryType = 1
	BinaryTypeResponse_SCS_WOW_BINARY   BinaryTypeResponse_Win32BinaryType = 2
	BinaryTypeResponse_SCS_PIF_BINARY   BinaryTypeResponse_Win32BinaryType = 3
	BinaryTypeResponse_SCS_POSIX_BINARY BinaryTypeResponse_Win32BinaryType = 4
	BinaryTypeResponse_SCS_OS216_BINARY BinaryTypeResponse_Win32BinaryType = 5
	BinaryTypeResponse_SCS_64BIT_BINARY BinaryTypeResponse_Win32BinaryType = 6
)

var BinaryTypeResponse_Win32BinaryType_name = map[int32]string{
	0: "SCS_32BIT_BINARY",
	1: "SCS_DOS_BINARY",
	2: "SCS_WOW_BINARY",
	3: "SCS_PIF_BINARY",
	4: "SCS_POSIX_BINARY",
	5: "SCS_OS216_BINARY",
	6: "SCS_64BIT_BINARY",
}
var BinaryTypeResponse_Win32BinaryType_value = map[string]int32{
	"SCS_32BIT_BINARY": 0,
	"SCS_DOS_BINARY":   1,
	"SCS_WOW_BINARY":   2,
	"SCS_PIF_BINARY":   3,
	"SCS_POSIX_BINARY": 4,
	"SCS_OS216_BINARY": 5,
	"SCS_64BIT_BINARY": 6,
}

func (x BinaryTypeResponse_Win32BinaryType) String() string {
	return proto.EnumName(BinaryTypeResponse_Win32BinaryType_name, int32(x))
}
func (BinaryTypeResponse_Win32BinaryType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{7, 0}
}

type LocalEnvironment struct {
	Empty                bool                         `protobuf:"varint,1,opt,name=empty,proto3" json:"empty,omitempty"`
	Variable             []*LocalEnvironment_Variable `protobuf:"bytes,2,rep,name=variable,proto3" json:"variable,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *LocalEnvironment) Reset()         { *m = LocalEnvironment{} }
func (m *LocalEnvironment) String() string { return proto.CompactTextString(m) }
func (*LocalEnvironment) ProtoMessage()    {}
func (*LocalEnvironment) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{0}
}
func (m *LocalEnvironment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalEnvironment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocalEnvironment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LocalEnvironment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalEnvironment.Merge(dst, src)
}
func (m *LocalEnvironment) XXX_Size() int {
	return m.Size()
}
func (m *LocalEnvironment) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalEnvironment.DiscardUnknown(m)
}

var xxx_messageInfo_LocalEnvironment proto.InternalMessageInfo

func (m *LocalEnvironment) GetEmpty() bool {
	if m != nil {
		return m.Empty
	}
	return false
}

func (m *LocalEnvironment) GetVariable() []*LocalEnvironment_Variable {
	if m != nil {
		return m.Variable
	}
	return nil
}

type LocalEnvironment_Variable struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Expand               bool     `protobuf:"varint,3,opt,name=expand,proto3" json:"expand,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocalEnvironment_Variable) Reset()         { *m = LocalEnvironment_Variable{} }
func (m *LocalEnvironment_Variable) String() string { return proto.CompactTextString(m) }
func (*LocalEnvironment_Variable) ProtoMessage()    {}
func (*LocalEnvironment_Variable) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{0, 0}
}
func (m *LocalEnvironment_Variable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalEnvironment_Variable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocalEnvironment_Variable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LocalEnvironment_Variable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalEnvironment_Variable.Merge(dst, src)
}
func (m *LocalEnvironment_Variable) XXX_Size() int {
	return m.Size()
}
func (m *LocalEnvironment_Variable) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalEnvironment_Variable.DiscardUnknown(m)
}

var xxx_messageInfo_LocalEnvironment_Variable proto.InternalMessageInfo

func (m *LocalEnvironment_Variable) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LocalEnvironment_Variable) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *LocalEnvironment_Variable) GetExpand() bool {
	if m != nil {
		return m.Expand
	}
	return false
}

type LocalExecutionParameters struct {
	ApplicationName       string              `protobuf:"bytes,1,opt,name=application_name,json=applicationName,proto3" json:"application_name,omitempty"`
	CommandLine           string              `protobuf:"bytes,2,opt,name=command_line,json=commandLine,proto3" json:"command_line,omitempty"`
	CurrentDirectory      string              `protobuf:"bytes,3,opt,name=current_directory,json=currentDirectory,proto3" json:"current_directory,omitempty"`
	TimeLimitMicros       uint64              `protobuf:"varint,4,opt,name=time_limit_micros,json=timeLimitMicros,proto3" json:"time_limit_micros,omitempty"`
	MemoryLimit           uint64              `protobuf:"varint,5,opt,name=memory_limit,json=memoryLimit,proto3" json:"memory_limit,omitempty"`
	CheckIdleness         bool                `protobuf:"varint,6,opt,name=check_idleness,json=checkIdleness,proto3" json:"check_idleness,omitempty"`
	Environment           *LocalEnvironment   `protobuf:"bytes,7,opt,name=environment,proto3" json:"environment,omitempty"`
	RestrictUi            bool                `protobuf:"varint,8,opt,name=restrict_ui,json=restrictUi,proto3" json:"restrict_ui,omitempty"`
	NoJob                 bool                `protobuf:"varint,9,opt,name=no_job,json=noJob,proto3" json:"no_job,omitempty"`
	ProcessLimit          uint32              `protobuf:"varint,10,opt,name=process_limit,json=processLimit,proto3" json:"process_limit,omitempty"`
	KernelTimeLimitMicros uint64              `protobuf:"varint,19,opt,name=kernel_time_limit_micros,json=kernelTimeLimitMicros,proto3" json:"kernel_time_limit_micros,omitempty"`
	WallTimeLimitMicros   uint64              `protobuf:"varint,20,opt,name=wall_time_limit_micros,json=wallTimeLimitMicros,proto3" json:"wall_time_limit_micros,omitempty"`
	StdIn                 *RedirectParameters `protobuf:"bytes,12,opt,name=std_in,json=stdIn,proto3" json:"std_in,omitempty"`
	StdOut                *RedirectParameters `protobuf:"bytes,13,opt,name=std_out,json=stdOut,proto3" json:"std_out,omitempty"`
	StdErr                *RedirectParameters `protobuf:"bytes,14,opt,name=std_err,json=stdErr,proto3" json:"std_err,omitempty"`
	CommandLineParameters []string            `protobuf:"bytes,16,rep,name=command_line_parameters,json=commandLineParameters,proto3" json:"command_line_parameters,omitempty"`
	SandboxId             string              `protobuf:"bytes,17,opt,name=sandbox_id,json=sandboxId,proto3" json:"sandbox_id,omitempty"`
	JoinStdoutStderr      bool                `protobuf:"varint,18,opt,name=join_stdout_stderr,json=joinStdoutStderr,proto3" json:"join_stdout_stderr,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}            `json:"-"`
	XXX_unrecognized      []byte              `json:"-"`
	XXX_sizecache         int32               `json:"-"`
}

func (m *LocalExecutionParameters) Reset()         { *m = LocalExecutionParameters{} }
func (m *LocalExecutionParameters) String() string { return proto.CompactTextString(m) }
func (*LocalExecutionParameters) ProtoMessage()    {}
func (*LocalExecutionParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{1}
}
func (m *LocalExecutionParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalExecutionParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocalExecutionParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LocalExecutionParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalExecutionParameters.Merge(dst, src)
}
func (m *LocalExecutionParameters) XXX_Size() int {
	return m.Size()
}
func (m *LocalExecutionParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalExecutionParameters.DiscardUnknown(m)
}

var xxx_messageInfo_LocalExecutionParameters proto.InternalMessageInfo

func (m *LocalExecutionParameters) GetApplicationName() string {
	if m != nil {
		return m.ApplicationName
	}
	return ""
}

func (m *LocalExecutionParameters) GetCommandLine() string {
	if m != nil {
		return m.CommandLine
	}
	return ""
}

func (m *LocalExecutionParameters) GetCurrentDirectory() string {
	if m != nil {
		return m.CurrentDirectory
	}
	return ""
}

func (m *LocalExecutionParameters) GetTimeLimitMicros() uint64 {
	if m != nil {
		return m.TimeLimitMicros
	}
	return 0
}

func (m *LocalExecutionParameters) GetMemoryLimit() uint64 {
	if m != nil {
		return m.MemoryLimit
	}
	return 0
}

func (m *LocalExecutionParameters) GetCheckIdleness() bool {
	if m != nil {
		return m.CheckIdleness
	}
	return false
}

func (m *LocalExecutionParameters) GetEnvironment() *LocalEnvironment {
	if m != nil {
		return m.Environment
	}
	return nil
}

func (m *LocalExecutionParameters) GetRestrictUi() bool {
	if m != nil {
		return m.RestrictUi
	}
	return false
}

func (m *LocalExecutionParameters) GetNoJob() bool {
	if m != nil {
		return m.NoJob
	}
	return false
}

func (m *LocalExecutionParameters) GetProcessLimit() uint32 {
	if m != nil {
		return m.ProcessLimit
	}
	return 0
}

func (m *LocalExecutionParameters) GetKernelTimeLimitMicros() uint64 {
	if m != nil {
		return m.KernelTimeLimitMicros
	}
	return 0
}

func (m *LocalExecutionParameters) GetWallTimeLimitMicros() uint64 {
	if m != nil {
		return m.WallTimeLimitMicros
	}
	return 0
}

func (m *LocalExecutionParameters) GetStdIn() *RedirectParameters {
	if m != nil {
		return m.StdIn
	}
	return nil
}

func (m *LocalExecutionParameters) GetStdOut() *RedirectParameters {
	if m != nil {
		return m.StdOut
	}
	return nil
}

func (m *LocalExecutionParameters) GetStdErr() *RedirectParameters {
	if m != nil {
		return m.StdErr
	}
	return nil
}

func (m *LocalExecutionParameters) GetCommandLineParameters() []string {
	if m != nil {
		return m.CommandLineParameters
	}
	return nil
}

func (m *LocalExecutionParameters) GetSandboxId() string {
	if m != nil {
		return m.SandboxId
	}
	return ""
}

func (m *LocalExecutionParameters) GetJoinStdoutStderr() bool {
	if m != nil {
		return m.JoinStdoutStderr
	}
	return false
}

type LocalExecuteConnected struct {
	First                *LocalExecutionParameters `protobuf:"bytes,1,opt,name=first,proto3" json:"first,omitempty"`
	Second               *LocalExecutionParameters `protobuf:"bytes,2,opt,name=second,proto3" json:"second,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *LocalExecuteConnected) Reset()         { *m = LocalExecuteConnected{} }
func (m *LocalExecuteConnected) String() string { return proto.CompactTextString(m) }
func (*LocalExecuteConnected) ProtoMessage()    {}
func (*LocalExecuteConnected) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{2}
}
func (m *LocalExecuteConnected) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalExecuteConnected) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocalExecuteConnected.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LocalExecuteConnected) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalExecuteConnected.Merge(dst, src)
}
func (m *LocalExecuteConnected) XXX_Size() int {
	return m.Size()
}
func (m *LocalExecuteConnected) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalExecuteConnected.DiscardUnknown(m)
}

var xxx_messageInfo_LocalExecuteConnected proto.InternalMessageInfo

func (m *LocalExecuteConnected) GetFirst() *LocalExecutionParameters {
	if m != nil {
		return m.First
	}
	return nil
}

func (m *LocalExecuteConnected) GetSecond() *LocalExecutionParameters {
	if m != nil {
		return m.Second
	}
	return nil
}

type LocalExecutionResult struct {
	Flags                *ExecutionResultFlags `protobuf:"bytes,1,opt,name=flags,proto3" json:"flags,omitempty"`
	Time                 *ExecutionResultTime  `protobuf:"bytes,2,opt,name=time,proto3" json:"time,omitempty"`
	Memory               uint64                `protobuf:"varint,3,opt,name=memory,proto3" json:"memory,omitempty"`
	ReturnCode           uint32                `protobuf:"varint,4,opt,name=return_code,json=returnCode,proto3" json:"return_code,omitempty"`
	StdOut               *Blob                 `protobuf:"bytes,5,opt,name=std_out,json=stdOut,proto3" json:"std_out,omitempty"`
	StdErr               *Blob                 `protobuf:"bytes,6,opt,name=std_err,json=stdErr,proto3" json:"std_err,omitempty"`
	TotalProcesses       uint64                `protobuf:"varint,7,opt,name=total_processes,json=totalProcesses,proto3" json:"total_processes,omitempty"`
	KillSignal           int32                 `protobuf:"varint,8,opt,name=kill_signal,json=killSignal,proto3" json:"kill_signal,omitempty"`
	StopSignal           int32                 `protobuf:"varint,9,opt,name=stop_signal,json=stopSignal,proto3" json:"stop_signal,omitempty"`
	Error                string                `protobuf:"bytes,10,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *LocalExecutionResult) Reset()         { *m = LocalExecutionResult{} }
func (m *LocalExecutionResult) String() string { return proto.CompactTextString(m) }
func (*LocalExecutionResult) ProtoMessage()    {}
func (*LocalExecutionResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{3}
}
func (m *LocalExecutionResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalExecutionResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocalExecutionResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LocalExecutionResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalExecutionResult.Merge(dst, src)
}
func (m *LocalExecutionResult) XXX_Size() int {
	return m.Size()
}
func (m *LocalExecutionResult) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalExecutionResult.DiscardUnknown(m)
}

var xxx_messageInfo_LocalExecutionResult proto.InternalMessageInfo

func (m *LocalExecutionResult) GetFlags() *ExecutionResultFlags {
	if m != nil {
		return m.Flags
	}
	return nil
}

func (m *LocalExecutionResult) GetTime() *ExecutionResultTime {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *LocalExecutionResult) GetMemory() uint64 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *LocalExecutionResult) GetReturnCode() uint32 {
	if m != nil {
		return m.ReturnCode
	}
	return 0
}

func (m *LocalExecutionResult) GetStdOut() *Blob {
	if m != nil {
		return m.StdOut
	}
	return nil
}

func (m *LocalExecutionResult) GetStdErr() *Blob {
	if m != nil {
		return m.StdErr
	}
	return nil
}

func (m *LocalExecutionResult) GetTotalProcesses() uint64 {
	if m != nil {
		return m.TotalProcesses
	}
	return 0
}

func (m *LocalExecutionResult) GetKillSignal() int32 {
	if m != nil {
		return m.KillSignal
	}
	return 0
}

func (m *LocalExecutionResult) GetStopSignal() int32 {
	if m != nil {
		return m.StopSignal
	}
	return 0
}

func (m *LocalExecutionResult) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type LocalExecuteConnectedResult struct {
	First                *LocalExecutionResult `protobuf:"bytes,1,opt,name=first,proto3" json:"first,omitempty"`
	Second               *LocalExecutionResult `protobuf:"bytes,2,opt,name=second,proto3" json:"second,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *LocalExecuteConnectedResult) Reset()         { *m = LocalExecuteConnectedResult{} }
func (m *LocalExecuteConnectedResult) String() string { return proto.CompactTextString(m) }
func (*LocalExecuteConnectedResult) ProtoMessage()    {}
func (*LocalExecuteConnectedResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{4}
}
func (m *LocalExecuteConnectedResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalExecuteConnectedResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocalExecuteConnectedResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LocalExecuteConnectedResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalExecuteConnectedResult.Merge(dst, src)
}
func (m *LocalExecuteConnectedResult) XXX_Size() int {
	return m.Size()
}
func (m *LocalExecuteConnectedResult) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalExecuteConnectedResult.DiscardUnknown(m)
}

var xxx_messageInfo_LocalExecuteConnectedResult proto.InternalMessageInfo

func (m *LocalExecuteConnectedResult) GetFirst() *LocalExecutionResult {
	if m != nil {
		return m.First
	}
	return nil
}

func (m *LocalExecuteConnectedResult) GetSecond() *LocalExecutionResult {
	if m != nil {
		return m.Second
	}
	return nil
}

type LocalExecution struct {
	Parameters           *LocalExecutionParameters `protobuf:"bytes,1,opt,name=parameters,proto3" json:"parameters,omitempty"`
	Result               *LocalExecutionResult     `protobuf:"bytes,2,opt,name=result,proto3" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *LocalExecution) Reset()         { *m = LocalExecution{} }
func (m *LocalExecution) String() string { return proto.CompactTextString(m) }
func (*LocalExecution) ProtoMessage()    {}
func (*LocalExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{5}
}
func (m *LocalExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocalExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LocalExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalExecution.Merge(dst, src)
}
func (m *LocalExecution) XXX_Size() int {
	return m.Size()
}
func (m *LocalExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalExecution.DiscardUnknown(m)
}

var xxx_messageInfo_LocalExecution proto.InternalMessageInfo

func (m *LocalExecution) GetParameters() *LocalExecutionParameters {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *LocalExecution) GetResult() *LocalExecutionResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type BinaryTypeRequest struct {
	Pathname             string   `protobuf:"bytes,1,opt,name=pathname,proto3" json:"pathname,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BinaryTypeRequest) Reset()         { *m = BinaryTypeRequest{} }
func (m *BinaryTypeRequest) String() string { return proto.CompactTextString(m) }
func (*BinaryTypeRequest) ProtoMessage()    {}
func (*BinaryTypeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{6}
}
func (m *BinaryTypeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinaryTypeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinaryTypeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BinaryTypeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinaryTypeRequest.Merge(dst, src)
}
func (m *BinaryTypeRequest) XXX_Size() int {
	return m.Size()
}
func (m *BinaryTypeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BinaryTypeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BinaryTypeRequest proto.InternalMessageInfo

func (m *BinaryTypeRequest) GetPathname() string {
	if m != nil {
		return m.Pathname
	}
	return ""
}

type BinaryTypeResponse struct {
	Failure              bool                               `protobuf:"varint,1,opt,name=failure,proto3" json:"failure,omitempty"`
	Result               BinaryTypeResponse_Win32BinaryType `protobuf:"varint,2,opt,name=result,proto3,enum=contester.proto.BinaryTypeResponse_Win32BinaryType" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *BinaryTypeResponse) Reset()         { *m = BinaryTypeResponse{} }
func (m *BinaryTypeResponse) String() string { return proto.CompactTextString(m) }
func (*BinaryTypeResponse) ProtoMessage()    {}
func (*BinaryTypeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{7}
}
func (m *BinaryTypeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinaryTypeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinaryTypeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BinaryTypeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinaryTypeResponse.Merge(dst, src)
}
func (m *BinaryTypeResponse) XXX_Size() int {
	return m.Size()
}
func (m *BinaryTypeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BinaryTypeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BinaryTypeResponse proto.InternalMessageInfo

func (m *BinaryTypeResponse) GetFailure() bool {
	if m != nil {
		return m.Failure
	}
	return false
}

func (m *BinaryTypeResponse) GetResult() BinaryTypeResponse_Win32BinaryType {
	if m != nil {
		return m.Result
	}
	return BinaryTypeResponse_SCS_32BIT_BINARY
}

type ClearSandboxRequest struct {
	Sandbox              string   `protobuf:"bytes,1,opt,name=sandbox,proto3" json:"sandbox,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClearSandboxRequest) Reset()         { *m = ClearSandboxRequest{} }
func (m *ClearSandboxRequest) String() string { return proto.CompactTextString(m) }
func (*ClearSandboxRequest) ProtoMessage()    {}
func (*ClearSandboxRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{8}
}
func (m *ClearSandboxRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearSandboxRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearSandboxRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ClearSandboxRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearSandboxRequest.Merge(dst, src)
}
func (m *ClearSandboxRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClearSandboxRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearSandboxRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClearSandboxRequest proto.InternalMessageInfo

func (m *ClearSandboxRequest) GetSandbox() string {
	if m != nil {
		return m.Sandbox
	}
	return ""
}

type IdentifyRequest struct {
	ContesterId          string   `protobuf:"bytes,1,opt,name=contester_id,json=contesterId,proto3" json:"contester_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IdentifyRequest) Reset()         { *m = IdentifyRequest{} }
func (m *IdentifyRequest) String() string { return proto.CompactTextString(m) }
func (*IdentifyRequest) ProtoMessage()    {}
func (*IdentifyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{9}
}
func (m *IdentifyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IdentifyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IdentifyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IdentifyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IdentifyRequest.Merge(dst, src)
}
func (m *IdentifyRequest) XXX_Size() int {
	return m.Size()
}
func (m *IdentifyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IdentifyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IdentifyRequest proto.InternalMessageInfo

func (m *IdentifyRequest) GetContesterId() string {
	if m != nil {
		return m.ContesterId
	}
	return ""
}

type SandboxLocations struct {
	Compile              string   `protobuf:"bytes,1,opt,name=compile,proto3" json:"compile,omitempty"`
	Run                  string   `protobuf:"bytes,2,opt,name=run,proto3" json:"run,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SandboxLocations) Reset()         { *m = SandboxLocations{} }
func (m *SandboxLocations) String() string { return proto.CompactTextString(m) }
func (*SandboxLocations) ProtoMessage()    {}
func (*SandboxLocations) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{10}
}
func (m *SandboxLocations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SandboxLocations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SandboxLocations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SandboxLocations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SandboxLocations.Merge(dst, src)
}
func (m *SandboxLocations) XXX_Size() int {
	return m.Size()
}
func (m *SandboxLocations) XXX_DiscardUnknown() {
	xxx_messageInfo_SandboxLocations.DiscardUnknown(m)
}

var xxx_messageInfo_SandboxLocations proto.InternalMessageInfo

func (m *SandboxLocations) GetCompile() string {
	if m != nil {
		return m.Compile
	}
	return ""
}

func (m *SandboxLocations) GetRun() string {
	if m != nil {
		return m.Run
	}
	return ""
}

type IdentifyResponse struct {
	InvokerId            string              `protobuf:"bytes,1,opt,name=invoker_id,json=invokerId,proto3" json:"invoker_id,omitempty"`
	Sandboxes            []*SandboxLocations `protobuf:"bytes,2,rep,name=sandboxes,proto3" json:"sandboxes,omitempty"`
	Environment          *LocalEnvironment   `protobuf:"bytes,3,opt,name=environment,proto3" json:"environment,omitempty"`
	Platform             string              `protobuf:"bytes,4,opt,name=platform,proto3" json:"platform,omitempty"`
	PathSeparator        string              `protobuf:"bytes,5,opt,name=path_separator,json=pathSeparator,proto3" json:"path_separator,omitempty"`
	Disks                []string            `protobuf:"bytes,6,rep,name=disks,proto3" json:"disks,omitempty"`
	ProgramFiles         []string            `protobuf:"bytes,7,rep,name=programFiles,proto3" json:"programFiles,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *IdentifyResponse) Reset()         { *m = IdentifyResponse{} }
func (m *IdentifyResponse) String() string { return proto.CompactTextString(m) }
func (*IdentifyResponse) ProtoMessage()    {}
func (*IdentifyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{11}
}
func (m *IdentifyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IdentifyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IdentifyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IdentifyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IdentifyResponse.Merge(dst, src)
}
func (m *IdentifyResponse) XXX_Size() int {
	return m.Size()
}
func (m *IdentifyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IdentifyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IdentifyResponse proto.InternalMessageInfo

func (m *IdentifyResponse) GetInvokerId() string {
	if m != nil {
		return m.InvokerId
	}
	return ""
}

func (m *IdentifyResponse) GetSandboxes() []*SandboxLocations {
	if m != nil {
		return m.Sandboxes
	}
	return nil
}

func (m *IdentifyResponse) GetEnvironment() *LocalEnvironment {
	if m != nil {
		return m.Environment
	}
	return nil
}

func (m *IdentifyResponse) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *IdentifyResponse) GetPathSeparator() string {
	if m != nil {
		return m.PathSeparator
	}
	return ""
}

func (m *IdentifyResponse) GetDisks() []string {
	if m != nil {
		return m.Disks
	}
	return nil
}

func (m *IdentifyResponse) GetProgramFiles() []string {
	if m != nil {
		return m.ProgramFiles
	}
	return nil
}

type FileStat struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	IsDirectory          bool     `protobuf:"varint,2,opt,name=is_directory,json=isDirectory,proto3" json:"is_directory,omitempty"`
	Size_                uint64   `protobuf:"varint,3,opt,name=size,proto3" json:"size,omitempty"`
	Checksum             string   `protobuf:"bytes,4,opt,name=checksum,proto3" json:"checksum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileStat) Reset()         { *m = FileStat{} }
func (m *FileStat) String() string { return proto.CompactTextString(m) }
func (*FileStat) ProtoMessage()    {}
func (*FileStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{12}
}
func (m *FileStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FileStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileStat.Merge(dst, src)
}
func (m *FileStat) XXX_Size() int {
	return m.Size()
}
func (m *FileStat) XXX_DiscardUnknown() {
	xxx_messageInfo_FileStat.DiscardUnknown(m)
}

var xxx_messageInfo_FileStat proto.InternalMessageInfo

func (m *FileStat) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FileStat) GetIsDirectory() bool {
	if m != nil {
		return m.IsDirectory
	}
	return false
}

func (m *FileStat) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *FileStat) GetChecksum() string {
	if m != nil {
		return m.Checksum
	}
	return ""
}

type StatRequest struct {
	Name                 []string `protobuf:"bytes,1,rep,name=name,proto3" json:"name,omitempty"`
	SandboxId            string   `protobuf:"bytes,2,opt,name=sandbox_id,json=sandboxId,proto3" json:"sandbox_id,omitempty"`
	Expand               bool     `protobuf:"varint,3,opt,name=expand,proto3" json:"expand,omitempty"`
	CalculateChecksum    bool     `protobuf:"varint,4,opt,name=calculate_checksum,json=calculateChecksum,proto3" json:"calculate_checksum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StatRequest) Reset()         { *m = StatRequest{} }
func (m *StatRequest) String() string { return proto.CompactTextString(m) }
func (*StatRequest) ProtoMessage()    {}
func (*StatRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{13}
}
func (m *StatRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StatRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatRequest.Merge(dst, src)
}
func (m *StatRequest) XXX_Size() int {
	return m.Size()
}
func (m *StatRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StatRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StatRequest proto.InternalMessageInfo

func (m *StatRequest) GetName() []string {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *StatRequest) GetSandboxId() string {
	if m != nil {
		return m.SandboxId
	}
	return ""
}

func (m *StatRequest) GetExpand() bool {
	if m != nil {
		return m.Expand
	}
	return false
}

func (m *StatRequest) GetCalculateChecksum() bool {
	if m != nil {
		return m.CalculateChecksum
	}
	return false
}

type FileStats struct {
	Entries              []*FileStat `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *FileStats) Reset()         { *m = FileStats{} }
func (m *FileStats) String() string { return proto.CompactTextString(m) }
func (*FileStats) ProtoMessage()    {}
func (*FileStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{14}
}
func (m *FileStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FileStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileStats.Merge(dst, src)
}
func (m *FileStats) XXX_Size() int {
	return m.Size()
}
func (m *FileStats) XXX_DiscardUnknown() {
	xxx_messageInfo_FileStats.DiscardUnknown(m)
}

var xxx_messageInfo_FileStats proto.InternalMessageInfo

func (m *FileStats) GetEntries() []*FileStat {
	if m != nil {
		return m.Entries
	}
	return nil
}

type GetRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetRequest) Reset()         { *m = GetRequest{} }
func (m *GetRequest) String() string { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()    {}
func (*GetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{15}
}
func (m *GetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRequest.Merge(dst, src)
}
func (m *GetRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRequest proto.InternalMessageInfo

func (m *GetRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type EmptyMessage struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EmptyMessage) Reset()         { *m = EmptyMessage{} }
func (m *EmptyMessage) String() string { return proto.CompactTextString(m) }
func (*EmptyMessage) ProtoMessage()    {}
func (*EmptyMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{16}
}
func (m *EmptyMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmptyMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EmptyMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EmptyMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmptyMessage.Merge(dst, src)
}
func (m *EmptyMessage) XXX_Size() int {
	return m.Size()
}
func (m *EmptyMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_EmptyMessage.DiscardUnknown(m)
}

var xxx_messageInfo_EmptyMessage proto.InternalMessageInfo

type CopyOperation struct {
	LocalFileName        string   `protobuf:"bytes,1,opt,name=local_file_name,json=localFileName,proto3" json:"local_file_name,omitempty"`
	RemoteLocation       string   `protobuf:"bytes,2,opt,name=remote_location,json=remoteLocation,proto3" json:"remote_location,omitempty"`
	Upload               bool     `protobuf:"varint,3,opt,name=upload,proto3" json:"upload,omitempty"`
	Checksum             string   `protobuf:"bytes,4,opt,name=checksum,proto3" json:"checksum,omitempty"`
	ModuleType           string   `protobuf:"bytes,5,opt,name=module_type,json=moduleType,proto3" json:"module_type,omitempty"`
	AuthorizationToken   string   `protobuf:"bytes,6,opt,name=authorization_token,json=authorizationToken,proto3" json:"authorization_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CopyOperation) Reset()         { *m = CopyOperation{} }
func (m *CopyOperation) String() string { return proto.CompactTextString(m) }
func (*CopyOperation) ProtoMessage()    {}
func (*CopyOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{17}
}
func (m *CopyOperation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CopyOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CopyOperation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CopyOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CopyOperation.Merge(dst, src)
}
func (m *CopyOperation) XXX_Size() int {
	return m.Size()
}
func (m *CopyOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_CopyOperation.DiscardUnknown(m)
}

var xxx_messageInfo_CopyOperation proto.InternalMessageInfo

func (m *CopyOperation) GetLocalFileName() string {
	if m != nil {
		return m.LocalFileName
	}
	return ""
}

func (m *CopyOperation) GetRemoteLocation() string {
	if m != nil {
		return m.RemoteLocation
	}
	return ""
}

func (m *CopyOperation) GetUpload() bool {
	if m != nil {
		return m.Upload
	}
	return false
}

func (m *CopyOperation) GetChecksum() string {
	if m != nil {
		return m.Checksum
	}
	return ""
}

func (m *CopyOperation) GetModuleType() string {
	if m != nil {
		return m.ModuleType
	}
	return ""
}

func (m *CopyOperation) GetAuthorizationToken() string {
	if m != nil {
		return m.AuthorizationToken
	}
	return ""
}

type CopyOperations struct {
	Entries              []*CopyOperation `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
	SandboxId            string           `protobuf:"bytes,2,opt,name=sandbox_id,json=sandboxId,proto3" json:"sandbox_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *CopyOperations) Reset()         { *m = CopyOperations{} }
func (m *CopyOperations) String() string { return proto.CompactTextString(m) }
func (*CopyOperations) ProtoMessage()    {}
func (*CopyOperations) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{18}
}
func (m *CopyOperations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CopyOperations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CopyOperations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CopyOperations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CopyOperations.Merge(dst, src)
}
func (m *CopyOperations) XXX_Size() int {
	return m.Size()
}
func (m *CopyOperations) XXX_DiscardUnknown() {
	xxx_messageInfo_CopyOperations.DiscardUnknown(m)
}

var xxx_messageInfo_CopyOperations proto.InternalMessageInfo

func (m *CopyOperations) GetEntries() []*CopyOperation {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *CopyOperations) GetSandboxId() string {
	if m != nil {
		return m.SandboxId
	}
	return ""
}

type NamePair struct {
	Source               string   `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Destination          string   `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NamePair) Reset()         { *m = NamePair{} }
func (m *NamePair) String() string { return proto.CompactTextString(m) }
func (*NamePair) ProtoMessage()    {}
func (*NamePair) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{19}
}
func (m *NamePair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamePair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamePair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NamePair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamePair.Merge(dst, src)
}
func (m *NamePair) XXX_Size() int {
	return m.Size()
}
func (m *NamePair) XXX_DiscardUnknown() {
	xxx_messageInfo_NamePair.DiscardUnknown(m)
}

var xxx_messageInfo_NamePair proto.InternalMessageInfo

func (m *NamePair) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *NamePair) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

type RepeatedNamePairEntries struct {
	Entries              []*NamePair `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
	SandboxId            string      `protobuf:"bytes,2,opt,name=sandbox_id,json=sandboxId,proto3" json:"sandbox_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *RepeatedNamePairEntries) Reset()         { *m = RepeatedNamePairEntries{} }
func (m *RepeatedNamePairEntries) String() string { return proto.CompactTextString(m) }
func (*RepeatedNamePairEntries) ProtoMessage()    {}
func (*RepeatedNamePairEntries) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{20}
}
func (m *RepeatedNamePairEntries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepeatedNamePairEntries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepeatedNamePairEntries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RepeatedNamePairEntries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepeatedNamePairEntries.Merge(dst, src)
}
func (m *RepeatedNamePairEntries) XXX_Size() int {
	return m.Size()
}
func (m *RepeatedNamePairEntries) XXX_DiscardUnknown() {
	xxx_messageInfo_RepeatedNamePairEntries.DiscardUnknown(m)
}

var xxx_messageInfo_RepeatedNamePairEntries proto.InternalMessageInfo

func (m *RepeatedNamePairEntries) GetEntries() []*NamePair {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *RepeatedNamePairEntries) GetSandboxId() string {
	if m != nil {
		return m.SandboxId
	}
	return ""
}

type RepeatedStringEntries struct {
	Entries              []string `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RepeatedStringEntries) Reset()         { *m = RepeatedStringEntries{} }
func (m *RepeatedStringEntries) String() string { return proto.CompactTextString(m) }
func (*RepeatedStringEntries) ProtoMessage()    {}
func (*RepeatedStringEntries) Descriptor() ([]byte, []int) {
	return fileDescriptor_Local_7d58cc41fae8dcb2, []int{21}
}
func (m *RepeatedStringEntries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepeatedStringEntries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepeatedStringEntries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RepeatedStringEntries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepeatedStringEntries.Merge(dst, src)
}
func (m *RepeatedStringEntries) XXX_Size() int {
	return m.Size()
}
func (m *RepeatedStringEntries) XXX_DiscardUnknown() {
	xxx_messageInfo_RepeatedStringEntries.DiscardUnknown(m)
}

var xxx_messageInfo_RepeatedStringEntries proto.InternalMessageInfo

func (m *RepeatedStringEntries) GetEntries() []string {
	if m != nil {
		return m.Entries
	}
	return nil
}

func init() {
	proto.RegisterType((*LocalEnvironment)(nil), "contester.proto.LocalEnvironment")
	proto.RegisterType((*LocalEnvironment_Variable)(nil), "contester.proto.LocalEnvironment.Variable")
	proto.RegisterType((*LocalExecutionParameters)(nil), "contester.proto.LocalExecutionParameters")
	proto.RegisterType((*LocalExecuteConnected)(nil), "contester.proto.LocalExecuteConnected")
	proto.RegisterType((*LocalExecutionResult)(nil), "contester.proto.LocalExecutionResult")
	proto.RegisterType((*LocalExecuteConnectedResult)(nil), "contester.proto.LocalExecuteConnectedResult")
	proto.RegisterType((*LocalExecution)(nil), "contester.proto.LocalExecution")
	proto.RegisterType((*BinaryTypeRequest)(nil), "contester.proto.BinaryTypeRequest")
	proto.RegisterType((*BinaryTypeResponse)(nil), "contester.proto.BinaryTypeResponse")
	proto.RegisterType((*ClearSandboxRequest)(nil), "contester.proto.ClearSandboxRequest")
	proto.RegisterType((*IdentifyRequest)(nil), "contester.proto.IdentifyRequest")
	proto.RegisterType((*SandboxLocations)(nil), "contester.proto.SandboxLocations")
	proto.RegisterType((*IdentifyResponse)(nil), "contester.proto.IdentifyResponse")
	proto.RegisterType((*FileStat)(nil), "contester.proto.FileStat")
	proto.RegisterType((*StatRequest)(nil), "contester.proto.StatRequest")
	proto.RegisterType((*FileStats)(nil), "contester.proto.FileStats")
	proto.RegisterType((*GetRequest)(nil), "contester.proto.GetRequest")
	proto.RegisterType((*EmptyMessage)(nil), "contester.proto.EmptyMessage")
	proto.RegisterType((*CopyOperation)(nil), "contester.proto.CopyOperation")
	proto.RegisterType((*CopyOperations)(nil), "contester.proto.CopyOperations")
	proto.RegisterType((*NamePair)(nil), "contester.proto.NamePair")
	proto.RegisterType((*RepeatedNamePairEntries)(nil), "contester.proto.RepeatedNamePairEntries")
	proto.RegisterType((*RepeatedStringEntries)(nil), "contester.proto.RepeatedStringEntries")
	proto.RegisterEnum("contester.proto.BinaryTypeResponse_Win32BinaryType", BinaryTypeResponse_Win32BinaryType_name, BinaryTypeResponse_Win32BinaryType_value)
}
func (m *LocalEnvironment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalEnvironment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Empty {
		dAtA[i] = 0x8
		i++
		if m.Empty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Variable) > 0 {
		for _, msg := range m.Variable {
			dAtA[i] = 0x12
			i++
			i = encodeVarintLocal(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LocalEnvironment_Variable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalEnvironment_Variable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.Expand {
		dAtA[i] = 0x18
		i++
		if m.Expand {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LocalExecutionParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalExecutionParameters) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApplicationName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.ApplicationName)))
		i += copy(dAtA[i:], m.ApplicationName)
	}
	if len(m.CommandLine) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.CommandLine)))
		i += copy(dAtA[i:], m.CommandLine)
	}
	if len(m.CurrentDirectory) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.CurrentDirectory)))
		i += copy(dAtA[i:], m.CurrentDirectory)
	}
	if m.TimeLimitMicros != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.TimeLimitMicros))
	}
	if m.MemoryLimit != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.MemoryLimit))
	}
	if m.CheckIdleness {
		dAtA[i] = 0x30
		i++
		if m.CheckIdleness {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Environment != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.Environment.Size()))
		n1, err := m.Environment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.RestrictUi {
		dAtA[i] = 0x40
		i++
		if m.RestrictUi {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NoJob {
		dAtA[i] = 0x48
		i++
		if m.NoJob {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ProcessLimit != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.ProcessLimit))
	}
	if m.StdIn != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.StdIn.Size()))
		n2, err := m.StdIn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.StdOut != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.StdOut.Size()))
		n3, err := m.StdOut.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.StdErr != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.StdErr.Size()))
		n4, err := m.StdErr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.CommandLineParameters) > 0 {
		for _, s := range m.CommandLineParameters {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.SandboxId) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.SandboxId)))
		i += copy(dAtA[i:], m.SandboxId)
	}
	if m.JoinStdoutStderr {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.JoinStdoutStderr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.KernelTimeLimitMicros != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.KernelTimeLimitMicros))
	}
	if m.WallTimeLimitMicros != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.WallTimeLimitMicros))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LocalExecuteConnected) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalExecuteConnected) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.First != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.First.Size()))
		n5, err := m.First.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Second != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.Second.Size()))
		n6, err := m.Second.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LocalExecutionResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalExecutionResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.Flags.Size()))
		n7, err := m.Flags.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Time != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.Time.Size()))
		n8, err := m.Time.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Memory != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.Memory))
	}
	if m.ReturnCode != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.ReturnCode))
	}
	if m.StdOut != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.StdOut.Size()))
		n9, err := m.StdOut.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.StdErr != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.StdErr.Size()))
		n10, err := m.StdErr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.TotalProcesses != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.TotalProcesses))
	}
	if m.KillSignal != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.KillSignal))
	}
	if m.StopSignal != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.StopSignal))
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LocalExecuteConnectedResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalExecuteConnectedResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.First != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.First.Size()))
		n11, err := m.First.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Second != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.Second.Size()))
		n12, err := m.Second.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LocalExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalExecution) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Parameters != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.Parameters.Size()))
		n13, err := m.Parameters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Result != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.Result.Size()))
		n14, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BinaryTypeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinaryTypeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pathname) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Pathname)))
		i += copy(dAtA[i:], m.Pathname)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BinaryTypeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinaryTypeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Failure {
		dAtA[i] = 0x8
		i++
		if m.Failure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Result != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.Result))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClearSandboxRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearSandboxRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sandbox) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Sandbox)))
		i += copy(dAtA[i:], m.Sandbox)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IdentifyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdentifyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ContesterId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.ContesterId)))
		i += copy(dAtA[i:], m.ContesterId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SandboxLocations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SandboxLocations) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Compile) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Compile)))
		i += copy(dAtA[i:], m.Compile)
	}
	if len(m.Run) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Run)))
		i += copy(dAtA[i:], m.Run)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IdentifyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdentifyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InvokerId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.InvokerId)))
		i += copy(dAtA[i:], m.InvokerId)
	}
	if len(m.Sandboxes) > 0 {
		for _, msg := range m.Sandboxes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintLocal(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Environment != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.Environment.Size()))
		n15, err := m.Environment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if len(m.PathSeparator) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.PathSeparator)))
		i += copy(dAtA[i:], m.PathSeparator)
	}
	if len(m.Disks) > 0 {
		for _, s := range m.Disks {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ProgramFiles) > 0 {
		for _, s := range m.ProgramFiles {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FileStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileStat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.IsDirectory {
		dAtA[i] = 0x10
		i++
		if m.IsDirectory {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLocal(dAtA, i, uint64(m.Size_))
	}
	if len(m.Checksum) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Checksum)))
		i += copy(dAtA[i:], m.Checksum)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		for _, s := range m.Name {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.SandboxId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.SandboxId)))
		i += copy(dAtA[i:], m.SandboxId)
	}
	if m.Expand {
		dAtA[i] = 0x18
		i++
		if m.Expand {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CalculateChecksum {
		dAtA[i] = 0x20
		i++
		if m.CalculateChecksum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FileStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintLocal(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EmptyMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmptyMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CopyOperation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CopyOperation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LocalFileName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.LocalFileName)))
		i += copy(dAtA[i:], m.LocalFileName)
	}
	if len(m.RemoteLocation) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.RemoteLocation)))
		i += copy(dAtA[i:], m.RemoteLocation)
	}
	if m.Upload {
		dAtA[i] = 0x18
		i++
		if m.Upload {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Checksum) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Checksum)))
		i += copy(dAtA[i:], m.Checksum)
	}
	if len(m.ModuleType) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.ModuleType)))
		i += copy(dAtA[i:], m.ModuleType)
	}
	if len(m.AuthorizationToken) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.AuthorizationToken)))
		i += copy(dAtA[i:], m.AuthorizationToken)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CopyOperations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CopyOperations) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintLocal(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SandboxId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.SandboxId)))
		i += copy(dAtA[i:], m.SandboxId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NamePair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamePair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Destination) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.Destination)))
		i += copy(dAtA[i:], m.Destination)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RepeatedNamePairEntries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepeatedNamePairEntries) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintLocal(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SandboxId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLocal(dAtA, i, uint64(len(m.SandboxId)))
		i += copy(dAtA[i:], m.SandboxId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RepeatedStringEntries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepeatedStringEntries) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, s := range m.Entries {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintLocal(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *LocalEnvironment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Empty {
		n += 2
	}
	if len(m.Variable) > 0 {
		for _, e := range m.Variable {
			l = e.Size()
			n += 1 + l + sovLocal(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocalEnvironment_Variable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.Expand {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocalExecutionParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApplicationName)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	l = len(m.CommandLine)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	l = len(m.CurrentDirectory)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.TimeLimitMicros != 0 {
		n += 1 + sovLocal(uint64(m.TimeLimitMicros))
	}
	if m.MemoryLimit != 0 {
		n += 1 + sovLocal(uint64(m.MemoryLimit))
	}
	if m.CheckIdleness {
		n += 2
	}
	if m.Environment != nil {
		l = m.Environment.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.RestrictUi {
		n += 2
	}
	if m.NoJob {
		n += 2
	}
	if m.ProcessLimit != 0 {
		n += 1 + sovLocal(uint64(m.ProcessLimit))
	}
	if m.StdIn != nil {
		l = m.StdIn.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.StdOut != nil {
		l = m.StdOut.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.StdErr != nil {
		l = m.StdErr.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if len(m.CommandLineParameters) > 0 {
		for _, s := range m.CommandLineParameters {
			l = len(s)
			n += 2 + l + sovLocal(uint64(l))
		}
	}
	l = len(m.SandboxId)
	if l > 0 {
		n += 2 + l + sovLocal(uint64(l))
	}
	if m.JoinStdoutStderr {
		n += 3
	}
	if m.KernelTimeLimitMicros != 0 {
		n += 2 + sovLocal(uint64(m.KernelTimeLimitMicros))
	}
	if m.WallTimeLimitMicros != 0 {
		n += 2 + sovLocal(uint64(m.WallTimeLimitMicros))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocalExecuteConnected) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.First != nil {
		l = m.First.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.Second != nil {
		l = m.Second.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocalExecutionResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flags != nil {
		l = m.Flags.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.Memory != 0 {
		n += 1 + sovLocal(uint64(m.Memory))
	}
	if m.ReturnCode != 0 {
		n += 1 + sovLocal(uint64(m.ReturnCode))
	}
	if m.StdOut != nil {
		l = m.StdOut.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.StdErr != nil {
		l = m.StdErr.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.TotalProcesses != 0 {
		n += 1 + sovLocal(uint64(m.TotalProcesses))
	}
	if m.KillSignal != 0 {
		n += 1 + sovLocal(uint64(m.KillSignal))
	}
	if m.StopSignal != 0 {
		n += 1 + sovLocal(uint64(m.StopSignal))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocalExecuteConnectedResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.First != nil {
		l = m.First.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.Second != nil {
		l = m.Second.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocalExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Parameters != nil {
		l = m.Parameters.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinaryTypeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pathname)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinaryTypeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Failure {
		n += 2
	}
	if m.Result != 0 {
		n += 1 + sovLocal(uint64(m.Result))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClearSandboxRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sandbox)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IdentifyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContesterId)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SandboxLocations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Compile)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	l = len(m.Run)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IdentifyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InvokerId)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if len(m.Sandboxes) > 0 {
		for _, e := range m.Sandboxes {
			l = e.Size()
			n += 1 + l + sovLocal(uint64(l))
		}
	}
	if m.Environment != nil {
		l = m.Environment.Size()
		n += 1 + l + sovLocal(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	l = len(m.PathSeparator)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if len(m.Disks) > 0 {
		for _, s := range m.Disks {
			l = len(s)
			n += 1 + l + sovLocal(uint64(l))
		}
	}
	if len(m.ProgramFiles) > 0 {
		for _, s := range m.ProgramFiles {
			l = len(s)
			n += 1 + l + sovLocal(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.IsDirectory {
		n += 2
	}
	if m.Size_ != 0 {
		n += 1 + sovLocal(uint64(m.Size_))
	}
	l = len(m.Checksum)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StatRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Name) > 0 {
		for _, s := range m.Name {
			l = len(s)
			n += 1 + l + sovLocal(uint64(l))
		}
	}
	l = len(m.SandboxId)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.Expand {
		n += 2
	}
	if m.CalculateChecksum {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLocal(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EmptyMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CopyOperation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LocalFileName)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	l = len(m.RemoteLocation)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.Upload {
		n += 2
	}
	l = len(m.Checksum)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	l = len(m.ModuleType)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	l = len(m.AuthorizationToken)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CopyOperations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLocal(uint64(l))
		}
	}
	l = len(m.SandboxId)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NamePair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepeatedNamePairEntries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovLocal(uint64(l))
		}
	}
	l = len(m.SandboxId)
	if l > 0 {
		n += 1 + l + sovLocal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepeatedStringEntries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, s := range m.Entries {
			l = len(s)
			n += 1 + l + sovLocal(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovLocal(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozLocal(x uint64) (n int) {
	return sovLocal(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LocalEnvironment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalEnvironment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalEnvironment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Empty = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variable = append(m.Variable, &LocalEnvironment_Variable{})
			if err := m.Variable[len(m.Variable)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalEnvironment_Variable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Variable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Variable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expand", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Expand = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalExecutionParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalExecutionParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalExecutionParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandLine", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommandLine = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentDirectory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentDirectory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeLimitMicros", wireType)
			}
			m.TimeLimitMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeLimitMicros |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryLimit", wireType)
			}
			m.MemoryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryLimit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckIdleness", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CheckIdleness = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Environment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Environment == nil {
				m.Environment = &LocalEnvironment{}
			}
			if err := m.Environment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestrictUi", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RestrictUi = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoJob", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoJob = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessLimit", wireType)
			}
			m.ProcessLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessLimit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StdIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StdIn == nil {
				m.StdIn = &RedirectParameters{}
			}
			if err := m.StdIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StdOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StdOut == nil {
				m.StdOut = &RedirectParameters{}
			}
			if err := m.StdOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StdErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StdErr == nil {
				m.StdErr = &RedirectParameters{}
			}
			if err := m.StdErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandLineParameters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommandLineParameters = append(m.CommandLineParameters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SandboxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SandboxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinStdoutStderr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.JoinStdoutStderr = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelTimeLimitMicros", wireType)
			}
			m.KernelTimeLimitMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KernelTimeLimitMicros |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallTimeLimitMicros", wireType)
			}
			m.WallTimeLimitMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WallTimeLimitMicros |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalExecuteConnected) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalExecuteConnected: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalExecuteConnected: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field First", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.First == nil {
				m.First = &LocalExecutionParameters{}
			}
			if err := m.First.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Second", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Second == nil {
				m.Second = &LocalExecutionParameters{}
			}
			if err := m.Second.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalExecutionResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalExecutionResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalExecutionResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Flags == nil {
				m.Flags = &ExecutionResultFlags{}
			}
			if err := m.Flags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &ExecutionResultTime{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnCode", wireType)
			}
			m.ReturnCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReturnCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StdOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StdOut == nil {
				m.StdOut = &Blob{}
			}
			if err := m.StdOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StdErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StdErr == nil {
				m.StdErr = &Blob{}
			}
			if err := m.StdErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalProcesses", wireType)
			}
			m.TotalProcesses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalProcesses |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillSignal", wireType)
			}
			m.KillSignal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KillSignal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopSignal", wireType)
			}
			m.StopSignal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StopSignal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalExecuteConnectedResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalExecuteConnectedResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalExecuteConnectedResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field First", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.First == nil {
				m.First = &LocalExecutionResult{}
			}
			if err := m.First.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Second", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Second == nil {
				m.Second = &LocalExecutionResult{}
			}
			if err := m.Second.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parameters == nil {
				m.Parameters = &LocalExecutionParameters{}
			}
			if err := m.Parameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &LocalExecutionResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinaryTypeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinaryTypeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinaryTypeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pathname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pathname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinaryTypeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinaryTypeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinaryTypeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failure = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (BinaryTypeResponse_Win32BinaryType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearSandboxRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearSandboxRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearSandboxRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sandbox", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sandbox = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdentifyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdentifyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdentifyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContesterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContesterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SandboxLocations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SandboxLocations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SandboxLocations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Compile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Run", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Run = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdentifyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdentifyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdentifyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvokerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvokerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sandboxes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sandboxes = append(m.Sandboxes, &SandboxLocations{})
			if err := m.Sandboxes[len(m.Sandboxes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Environment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Environment == nil {
				m.Environment = &LocalEnvironment{}
			}
			if err := m.Environment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathSeparator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathSeparator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disks", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Disks = append(m.Disks, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramFiles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramFiles = append(m.ProgramFiles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDirectory", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDirectory = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checksum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SandboxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SandboxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expand", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Expand = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CalculateChecksum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CalculateChecksum = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &FileStat{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmptyMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmptyMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmptyMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CopyOperation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CopyOperation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CopyOperation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalFileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalFileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteLocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Upload = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checksum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizationToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorizationToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CopyOperations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CopyOperations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CopyOperations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &CopyOperation{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SandboxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SandboxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamePair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamePair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamePair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepeatedNamePairEntries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepeatedNamePairEntries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepeatedNamePairEntries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &NamePair{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SandboxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SandboxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepeatedStringEntries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepeatedStringEntries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepeatedStringEntries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocal
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLocal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLocal(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLocal
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLocal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthLocal
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLocal
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLocal(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLocal = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLocal   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("Local.proto", fileDescriptor_Local_7d58cc41fae8dcb2) }

var fileDescriptor_Local_7d58cc41fae8dcb2 = []byte{
	// 1524 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0x5f, 0x73, 0x1b, 0x49,
	0x11, 0xbf, 0xb5, 0xfe, 0x58, 0x6a, 0x59, 0x7f, 0x3c, 0xb6, 0xef, 0x96, 0xc0, 0x19, 0x65, 0x8f,
	0x70, 0xbe, 0x03, 0x94, 0x3a, 0x39, 0x15, 0x28, 0xfe, 0xc7, 0x8e, 0x4d, 0x09, 0x9c, 0xd8, 0xb5,
	0x32, 0x04, 0x9e, 0xb6, 0xd6, 0xbb, 0x63, 0x67, 0xe2, 0xdd, 0x99, 0xcd, 0xcc, 0xac, 0x89, 0xf2,
	0x05, 0xf8, 0x0a, 0xfc, 0x79, 0xa4, 0x28, 0xbe, 0x00, 0xcf, 0x3c, 0xf3, 0xc8, 0x23, 0x8f, 0x54,
	0xa8, 0xe2, 0x73, 0x50, 0x33, 0x3b, 0x23, 0xad, 0x24, 0x07, 0xdb, 0xf7, 0xa4, 0xed, 0xdf, 0x74,
	0x4f, 0xf7, 0xf4, 0xfc, 0xba, 0xa7, 0x05, 0xad, 0x23, 0x16, 0x85, 0xc9, 0x20, 0xe3, 0x4c, 0x32,
	0xd4, 0x8d, 0x18, 0x95, 0x58, 0x48, 0xcc, 0x0b, 0xe0, 0x5e, 0x6b, 0x2f, 0x61, 0x67, 0xc2, 0x08,
	0xdd, 0x83, 0x37, 0x38, 0xca, 0x25, 0x61, 0xb4, 0x00, 0xbc, 0xbf, 0x3b, 0xd0, 0xd3, 0xe6, 0x07,
	0xf4, 0x8a, 0x70, 0x46, 0x53, 0x4c, 0x25, 0xda, 0x84, 0x1a, 0x4e, 0x33, 0x39, 0x71, 0x9d, 0xbe,
	0xb3, 0xd3, 0xf0, 0x0b, 0x01, 0x1d, 0x42, 0xe3, 0x2a, 0xe4, 0x24, 0x3c, 0x4b, 0xb0, 0xbb, 0xd2,
	0xaf, 0xec, 0xb4, 0x86, 0x9f, 0x0f, 0x16, 0x9c, 0x0d, 0x16, 0xb7, 0x1a, 0xfc, 0xca, 0x58, 0xf8,
	0x53, 0xdb, 0x7b, 0x47, 0xd0, 0xb0, 0x28, 0x42, 0x50, 0xa5, 0x61, 0x8a, 0xb5, 0xa3, 0xa6, 0xaf,
	0xbf, 0x95, 0xf7, 0xab, 0x30, 0xc9, 0x95, 0x13, 0x05, 0x16, 0x02, 0xfa, 0x10, 0xea, 0xf8, 0x4d,
	0x16, 0xd2, 0xd8, 0xad, 0xe8, 0xa0, 0x8c, 0xe4, 0xfd, 0xab, 0x0e, 0x6e, 0xe1, 0xd5, 0x9e, 0xec,
	0x24, 0xe4, 0x61, 0x8a, 0x25, 0xe6, 0x02, 0x7d, 0x06, 0xbd, 0x30, 0xcb, 0x12, 0x12, 0x85, 0x6a,
	0x21, 0x28, 0xb9, 0xea, 0x96, 0xf0, 0xe7, 0xca, 0xeb, 0x7d, 0x58, 0x8b, 0x58, 0x9a, 0x86, 0x34,
	0x0e, 0x12, 0x42, 0xad, 0xf3, 0x96, 0xc1, 0x8e, 0x08, 0xc5, 0xe8, 0x5b, 0xb0, 0x1e, 0xe5, 0x9c,
	0x63, 0x2a, 0x83, 0x98, 0x70, 0x1c, 0x49, 0xc6, 0x27, 0x3a, 0x9a, 0xa6, 0xdf, 0x33, 0x0b, 0x4f,
	0x2d, 0x8e, 0x3e, 0x87, 0x75, 0x49, 0x52, 0x1c, 0x24, 0x24, 0x25, 0x32, 0x48, 0x49, 0xc4, 0x99,
	0x70, 0xab, 0x7d, 0x67, 0xa7, 0xea, 0x77, 0xd5, 0xc2, 0x91, 0xc2, 0x9f, 0x69, 0x58, 0xf9, 0x4e,
	0x71, 0xca, 0xf8, 0xa4, 0xd0, 0x76, 0x6b, 0x5a, 0xad, 0x55, 0x60, 0x5a, 0x11, 0x3d, 0x80, 0x4e,
	0xf4, 0x12, 0x47, 0x97, 0x01, 0x89, 0x13, 0x4c, 0xb1, 0x10, 0x6e, 0x5d, 0xa7, 0xa1, 0xad, 0xd1,
	0x91, 0x01, 0xd1, 0x3e, 0xb4, 0xf0, 0x2c, 0xfb, 0xee, 0x6a, 0xdf, 0xd9, 0x69, 0x0d, 0xef, 0xdf,
	0x78, 0x4d, 0x7e, 0xd9, 0x0a, 0x7d, 0x1d, 0x5a, 0x1c, 0x0b, 0xc9, 0x49, 0x24, 0x83, 0x9c, 0xb8,
	0x0d, 0xed, 0x08, 0x2c, 0xf4, 0x4b, 0x82, 0xb6, 0xa0, 0x4e, 0x59, 0xf0, 0x8a, 0x9d, 0xb9, 0xcd,
	0x82, 0x20, 0x94, 0xfd, 0x9c, 0x9d, 0xa1, 0x4f, 0xa0, 0x9d, 0x71, 0x16, 0x61, 0x21, 0xcc, 0x39,
	0xa0, 0xef, 0xec, 0xb4, 0xfd, 0x35, 0x03, 0x16, 0x07, 0xf9, 0x3e, 0xd4, 0x85, 0x8c, 0x03, 0x42,
	0xdd, 0x35, 0x1d, 0xdc, 0x27, 0x4b, 0xc1, 0xf9, 0xb8, 0xc8, 0xee, 0xec, 0x1e, 0xfd, 0x9a, 0x90,
	0xf1, 0x88, 0xa2, 0x1f, 0xc2, 0xaa, 0xb2, 0x65, 0xb9, 0x74, 0xdb, 0xb7, 0x37, 0x56, 0xfe, 0x8e,
	0x73, 0x69, 0xad, 0x31, 0xe7, 0x6e, 0xe7, 0x6e, 0xd6, 0x07, 0x9c, 0xa3, 0xc7, 0xf0, 0x51, 0x99,
	0x1f, 0x41, 0x36, 0x55, 0x71, 0x7b, 0xfd, 0xca, 0x4e, 0xd3, 0xdf, 0x2a, 0x51, 0xa5, 0x44, 0xc1,
	0x8f, 0x01, 0x44, 0x48, 0xe3, 0x33, 0xf6, 0x26, 0x20, 0xb1, 0xbb, 0xae, 0xd9, 0xd2, 0x34, 0xc8,
	0x28, 0x46, 0xdf, 0x06, 0xf4, 0x8a, 0x11, 0x1a, 0x08, 0x19, 0xb3, 0x5c, 0xaa, 0x1f, 0x15, 0x1f,
	0xd2, 0x69, 0xed, 0xa9, 0x95, 0xb1, 0x5e, 0x18, 0x6b, 0x1c, 0x7d, 0x17, 0xdc, 0x4b, 0xcc, 0x29,
	0x4e, 0x82, 0x65, 0x6e, 0x6d, 0x68, 0xd2, 0x6c, 0x15, 0xeb, 0xa7, 0x0b, 0x0c, 0xdb, 0x85, 0x0f,
	0x7f, 0x1b, 0x26, 0xd7, 0x99, 0x6d, 0x6a, 0xb3, 0x0d, 0xb5, 0xba, 0x60, 0xe4, 0xfd, 0xc9, 0x81,
	0xad, 0x52, 0x69, 0xe1, 0x7d, 0x46, 0x29, 0x8e, 0x24, 0x8e, 0xd1, 0x4f, 0xa0, 0x76, 0x4e, 0xb8,
	0x90, 0xba, 0x98, 0x5a, 0xc3, 0xcf, 0xde, 0x43, 0xb0, 0xe5, 0x8a, 0xf4, 0x0b, 0x3b, 0xf4, 0x04,
	0xea, 0x02, 0x47, 0x8c, 0xc6, 0xba, 0xce, 0xee, 0xb4, 0x83, 0x31, 0xf4, 0xfe, 0x5a, 0x81, 0xcd,
	0x79, 0x25, 0x1f, 0x8b, 0x3c, 0x91, 0xe8, 0x07, 0x50, 0x3b, 0x4f, 0xc2, 0x0b, 0x61, 0x82, 0x7b,
	0xb0, 0xb4, 0xf5, 0x82, 0xc1, 0xa1, 0x52, 0xf6, 0x0b, 0x1b, 0xf4, 0x3d, 0xa8, 0xaa, 0x1c, 0x99,
	0xb0, 0xbe, 0x71, 0x93, 0xad, 0x4a, 0x99, 0xaf, 0x2d, 0x54, 0x83, 0x2a, 0x0a, 0x56, 0xb7, 0x84,
	0xaa, 0x6f, 0xa4, 0xa2, 0x9a, 0x64, 0xce, 0x69, 0x10, 0xb1, 0x18, 0xeb, 0x16, 0xd0, 0x56, 0xd5,
	0xa4, 0xa0, 0x7d, 0x16, 0x63, 0x34, 0x98, 0xb1, 0xba, 0xa6, 0xbd, 0x6e, 0x2d, 0x79, 0x55, 0x2d,
	0x7c, 0xca, 0xe3, 0xc1, 0x8c, 0xc7, 0xf5, 0x9b, 0xf4, 0x15, 0x73, 0x3f, 0x85, 0xae, 0x64, 0x32,
	0x4c, 0x02, 0x53, 0x87, 0x58, 0xe8, 0xbe, 0x50, 0xf5, 0x3b, 0x1a, 0x3e, 0xb1, 0xa8, 0x8a, 0xf4,
	0x92, 0x24, 0x49, 0x20, 0xc8, 0x05, 0x0d, 0x13, 0x5d, 0xf7, 0x35, 0x1f, 0x14, 0x34, 0xd6, 0x88,
	0x52, 0x10, 0x92, 0x65, 0x56, 0xa1, 0x59, 0x28, 0x28, 0xc8, 0x28, 0xa8, 0x87, 0x83, 0x73, 0xc6,
	0x75, 0xe5, 0x37, 0xfd, 0x42, 0xf0, 0xfe, 0xe0, 0xc0, 0x57, 0xaf, 0xe5, 0x51, 0xe9, 0xc2, 0x4a,
	0x6c, 0x7a, 0x70, 0x03, 0x17, 0x0a, 0x2b, 0xcb, 0xa4, 0x1f, 0x2d, 0x30, 0xe9, 0x96, 0xd6, 0x96,
	0x45, 0x7f, 0x74, 0xa0, 0x33, 0xaf, 0x80, 0x46, 0x00, 0xa5, 0xe2, 0xbe, 0x33, 0xc3, 0x4b, 0xc6,
	0x2a, 0x38, 0xae, 0xfd, 0xdd, 0x31, 0xb8, 0xc2, 0xc8, 0x7b, 0x08, 0xeb, 0x7b, 0x84, 0x86, 0x7c,
	0x72, 0x3a, 0xc9, 0xb0, 0x8f, 0x5f, 0xe7, 0x58, 0x48, 0x74, 0x0f, 0x1a, 0x59, 0x28, 0x5f, 0x96,
	0xde, 0xb2, 0xa9, 0xec, 0xfd, 0x79, 0x05, 0x50, 0xd9, 0x42, 0x64, 0x8c, 0x0a, 0x8c, 0x5c, 0x58,
	0x3d, 0x0f, 0x49, 0x92, 0x73, 0x6c, 0x5e, 0x74, 0x2b, 0xa2, 0x5f, 0xcc, 0x05, 0xd8, 0x19, 0xee,
	0x2e, 0x53, 0x69, 0x69, 0xbb, 0xc1, 0x0b, 0x42, 0x77, 0x87, 0x25, 0xdc, 0x86, 0xfb, 0x17, 0x07,
	0xba, 0x0b, 0x6b, 0x68, 0x13, 0x7a, 0xe3, 0xfd, 0x71, 0xb0, 0x3b, 0xdc, 0x1b, 0x9d, 0x06, 0x7b,
	0xa3, 0xe7, 0x4f, 0xfc, 0xdf, 0xf4, 0x3e, 0x40, 0x08, 0x3a, 0x0a, 0x7d, 0x7a, 0x3c, 0xb6, 0x98,
	0x63, 0xb1, 0x17, 0xc7, 0x2f, 0x2c, 0xb6, 0x62, 0xb1, 0x93, 0xd1, 0xa1, 0xc5, 0x2a, 0x76, 0xc7,
	0x93, 0xe3, 0xf1, 0xe8, 0xd7, 0x16, 0xad, 0x5a, 0xf4, 0x78, 0x3c, 0xfc, 0xe2, 0xb1, 0x45, 0x6b,
	0x16, 0x7d, 0xfc, 0xa8, 0xe4, 0xbd, 0xee, 0x3d, 0x84, 0x8d, 0xfd, 0x04, 0x87, 0x7c, 0x5c, 0x74,
	0x61, 0x9b, 0x58, 0x17, 0x56, 0x4d, 0x5f, 0x36, 0x79, 0xb5, 0xa2, 0xf7, 0x08, 0xba, 0xa3, 0x18,
	0x53, 0x49, 0xce, 0x27, 0x56, 0x59, 0x8f, 0x0b, 0x26, 0x53, 0xaa, 0xb1, 0x3b, 0x76, 0x5c, 0x30,
	0xd8, 0x28, 0xf6, 0x7e, 0x0c, 0x3d, 0xe3, 0x41, 0x5d, 0xb2, 0xba, 0x5e, 0xa1, 0x7c, 0x44, 0x2c,
	0xcd, 0x48, 0x62, 0xef, 0xce, 0x8a, 0xa8, 0x07, 0x15, 0x9e, 0x53, 0x33, 0x76, 0xa8, 0x4f, 0xef,
	0x6f, 0x2b, 0xd0, 0x9b, 0xb9, 0x35, 0x57, 0xf9, 0x31, 0x00, 0xa1, 0x57, 0xec, 0xb2, 0xec, 0xb5,
	0x69, 0x90, 0x91, 0x6a, 0xcc, 0xf6, 0x6d, 0xc1, 0xc2, 0x0c, 0x69, 0xcb, 0xaf, 0xff, 0x62, 0x54,
	0xfe, 0xcc, 0x66, 0x71, 0x80, 0xa8, 0x7c, 0xa9, 0x01, 0x42, 0x51, 0x34, 0x09, 0xe5, 0x39, 0xe3,
	0xa9, 0xee, 0x77, 0x8a, 0xa2, 0x46, 0x56, 0x83, 0x8c, 0xa2, 0x6b, 0x20, 0xb0, 0xaa, 0x13, 0xc9,
	0xb8, 0x6e, 0x7a, 0x4d, 0xbf, 0xad, 0xd0, 0xb1, 0x05, 0x55, 0x27, 0x89, 0x89, 0xb8, 0x54, 0x63,
	0x8e, 0x7a, 0x5c, 0x0b, 0x01, 0x79, 0xa0, 0x86, 0x89, 0x0b, 0x1e, 0xa6, 0x87, 0x24, 0xd1, 0x7d,
	0x4c, 0x2d, 0xce, 0x61, 0xde, 0x6b, 0x68, 0xa8, 0x8f, 0xb1, 0x0c, 0xe5, 0xb5, 0xe3, 0xe5, 0x7d,
	0x58, 0x23, 0xa2, 0x34, 0xc0, 0xad, 0xe8, 0x8a, 0x68, 0x11, 0x31, 0x9b, 0xdd, 0x10, 0x54, 0x05,
	0x79, 0x8b, 0x4d, 0x23, 0xd7, 0xdf, 0xea, 0x4c, 0x7a, 0xd4, 0x12, 0xf9, 0xf4, 0x4c, 0x56, 0xf6,
	0x7e, 0xe7, 0x40, 0x4b, 0xf9, 0xb3, 0xe4, 0x98, 0xb9, 0xad, 0x4c, 0xdd, 0xce, 0xcf, 0x01, 0x2b,
	0x8b, 0x73, 0xc0, 0x7b, 0xc6, 0x5b, 0xf4, 0x1d, 0x40, 0x51, 0x98, 0x44, 0x79, 0x12, 0x4a, 0x1c,
	0xcc, 0x05, 0xd0, 0xf0, 0xd7, 0xa7, 0x2b, 0xfb, 0x36, 0x92, 0x9f, 0x42, 0xd3, 0x1e, 0x5e, 0x3d,
	0xfa, 0xab, 0x98, 0x4a, 0x4e, 0xb0, 0xd0, 0x91, 0xb4, 0x86, 0x5f, 0x59, 0xba, 0x47, 0xab, 0xec,
	0x5b, 0x4d, 0xaf, 0x0f, 0xf0, 0x33, 0x7c, 0xcd, 0x49, 0xa6, 0x09, 0xf4, 0x3a, 0xb0, 0x76, 0xa0,
	0xfe, 0x10, 0x3c, 0xc3, 0x42, 0x84, 0x17, 0xd8, 0xfb, 0xaf, 0x03, 0xed, 0x7d, 0x96, 0x4d, 0x8e,
	0x33, 0xcc, 0x35, 0xa1, 0xd0, 0x37, 0xa1, 0x9b, 0x28, 0x82, 0x04, 0xe7, 0x24, 0xc1, 0xe5, 0xa9,
	0xbb, 0xad, 0x61, 0xe5, 0x54, 0xcf, 0xdc, 0x9f, 0x42, 0x97, 0xe3, 0x94, 0x49, 0x1c, 0x24, 0x86,
	0x8b, 0x26, 0x31, 0x9d, 0x02, 0xb6, 0x0c, 0x55, 0xd9, 0xc9, 0xb3, 0x84, 0x85, 0xd3, 0xec, 0x14,
	0xd2, 0xff, 0xbb, 0x14, 0xf5, 0x58, 0xa5, 0x2c, 0xce, 0x13, 0x1c, 0xc8, 0x49, 0x86, 0x0d, 0xcb,
	0xa0, 0x80, 0x74, 0x6b, 0x7a, 0x08, 0x1b, 0x61, 0x2e, 0x5f, 0x32, 0x4e, 0xde, 0x16, 0x7f, 0x0f,
	0x24, 0xbb, 0xc4, 0x54, 0xbf, 0xa9, 0x4d, 0x1f, 0xcd, 0x2d, 0x9d, 0xaa, 0x15, 0x8f, 0x40, 0x67,
	0xee, 0x9c, 0x6a, 0x5a, 0x58, 0xc8, 0xf0, 0xf6, 0x52, 0x86, 0xe7, 0x2c, 0xa6, 0x69, 0xbe, 0x81,
	0x0e, 0xde, 0x53, 0x68, 0xa8, 0x0c, 0x9d, 0x84, 0x84, 0xab, 0xc3, 0x0b, 0x96, 0xf3, 0xc8, 0x26,
	0xd1, 0x48, 0xa8, 0x0f, 0xad, 0x18, 0x0b, 0x49, 0x68, 0x39, 0x73, 0x65, 0xc8, 0x4b, 0xe1, 0x23,
	0x1f, 0x67, 0x38, 0x94, 0x38, 0xb6, 0xbb, 0x1d, 0x18, 0xff, 0xb7, 0xe0, 0x86, 0x35, 0xb9, 0x75,
	0xd0, 0x5f, 0xc0, 0x96, 0x75, 0x37, 0x96, 0x9c, 0xd0, 0x0b, 0xeb, 0xcc, 0x9d, 0x77, 0xd6, 0x9c,
	0xee, 0xb8, 0x37, 0xf8, 0xc7, 0xbb, 0x6d, 0xe7, 0x9f, 0xef, 0xb6, 0x9d, 0x7f, 0xbf, 0xdb, 0x76,
	0x7e, 0xff, 0x9f, 0xed, 0x0f, 0xe0, 0x6b, 0x8c, 0x5f, 0x0c, 0xd4, 0x11, 0x2e, 0x78, 0x38, 0x59,
	0x8c, 0xe9, 0xac, 0xae, 0x7f, 0x76, 0xff, 0x17, 0x00, 0x00, 0xff, 0xff, 0x5e, 0xd1, 0x10, 0xe1,
	0xf3, 0x0e, 0x00, 0x00,
}
